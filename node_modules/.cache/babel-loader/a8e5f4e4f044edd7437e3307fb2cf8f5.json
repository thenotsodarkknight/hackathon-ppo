{"ast":null,"code":"import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\nvar AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n  if (series.missingValues) {\n    return series.missingValues;\n  }\n\n  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n  var fields = SeriesBinder.current.bindPoint(series, null, item);\n  var valueFields = fields.valueFields;\n\n  for (var field in valueFields) {\n    if (convertableToNumber(valueFields[field])) {\n      return true;\n    }\n  }\n}\n\nfunction findNext(ref) {\n  var start = ref.start;\n  var dir = ref.dir;\n  var min = ref.min;\n  var max = ref.max;\n  var getter = ref.getter;\n  var hasItem = ref.hasItem;\n  var series = ref.series;\n  var pointHasValue, outPoint;\n  var idx = start;\n\n  do {\n    idx += dir; //aggregating and binding the item takes too much time for large number of categories\n    //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n\n    if (hasItem(idx)) {\n      outPoint = getter(idx);\n      pointHasValue = hasValue(series, outPoint.item);\n    }\n  } while (min <= idx && idx <= max && !pointHasValue);\n\n  if (pointHasValue) {\n    return outPoint;\n  }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n  var min = range.min;\n  var max = range.max;\n  var hasMinPoint = min > 0 && min < count;\n  var hasMaxPoint = max + 1 < count;\n\n  if (hasMinPoint || hasMaxPoint) {\n    var missingValues = seriesMissingValues(series);\n    var minPoint, maxPoint;\n\n    if (missingValues !== INTERPOLATE) {\n      if (hasMinPoint) {\n        minPoint = getter(min - 1);\n      }\n\n      if (hasMaxPoint) {\n        maxPoint = getter(max + 1);\n      }\n    } else {\n      var outPoint, pointHasValue;\n\n      if (hasMinPoint) {\n        outPoint = getter(min - 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          minPoint = findNext({\n            start: min,\n            dir: -1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          minPoint = outPoint;\n        }\n      }\n\n      if (hasMaxPoint) {\n        outPoint = getter(max + 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          maxPoint = findNext({\n            start: max,\n            dir: 1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          maxPoint = outPoint;\n        }\n      }\n    }\n\n    if (minPoint) {\n      series._outOfRangeMinPoint = minPoint;\n    }\n\n    if (maxPoint) {\n      series._outOfRangeMaxPoint = maxPoint;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js"],"names":["INTERPOLATE","ZERO","convertableToNumber","SeriesBinder","AREA_REGEX","seriesMissingValues","series","missingValues","test","type","stack","hasValue","item","fields","current","bindPoint","valueFields","field","findNext","ref","start","dir","min","max","getter","hasItem","pointHasValue","outPoint","idx","createOutOfRangePoints","range","count","hasMinPoint","hasMaxPoint","minPoint","maxPoint","_outOfRangeMinPoint","_outOfRangeMaxPoint"],"mappings":"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","sourcesContent":["import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\n\nvar AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n    if (series.missingValues) {\n        return series.missingValues;\n    }\n\n    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n    var fields = SeriesBinder.current.bindPoint(series, null, item);\n    var valueFields = fields.valueFields;\n\n    for (var field in valueFields) {\n        if (convertableToNumber(valueFields[field])) {\n            return true;\n        }\n    }\n}\n\nfunction findNext(ref) {\n    var start = ref.start;\n    var dir = ref.dir;\n    var min = ref.min;\n    var max = ref.max;\n    var getter = ref.getter;\n    var hasItem = ref.hasItem;\n    var series = ref.series;\n\n    var pointHasValue, outPoint;\n    var idx = start;\n    do {\n        idx += dir;\n        //aggregating and binding the item takes too much time for large number of categories\n        //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n        if (hasItem(idx)) {\n            outPoint = getter(idx);\n            pointHasValue = hasValue(series, outPoint.item);\n        }\n    } while (min <= idx && idx <= max && !pointHasValue);\n\n    if (pointHasValue) {\n        return outPoint;\n    }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n    var min = range.min;\n    var max = range.max;\n    var hasMinPoint = min > 0 && min < count;\n    var hasMaxPoint = max + 1 < count;\n\n    if (hasMinPoint || hasMaxPoint) {\n        var missingValues = seriesMissingValues(series);\n        var minPoint, maxPoint;\n        if (missingValues !== INTERPOLATE) {\n            if (hasMinPoint) {\n                minPoint = getter(min - 1);\n            }\n\n            if (hasMaxPoint) {\n                maxPoint = getter(max + 1);\n            }\n        } else {\n            var outPoint, pointHasValue;\n            if (hasMinPoint) {\n                outPoint = getter(min - 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    minPoint = findNext({\n                        start: min,\n                        dir: -1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    minPoint = outPoint;\n                }\n            }\n\n            if (hasMaxPoint) {\n                outPoint = getter(max + 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    maxPoint = findNext({\n                        start: max,\n                        dir: 1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    maxPoint = outPoint;\n                }\n            }\n        }\n\n        if (minPoint) {\n            series._outOfRangeMinPoint = minPoint;\n        }\n\n        if (maxPoint) {\n            series._outOfRangeMaxPoint = maxPoint;\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}