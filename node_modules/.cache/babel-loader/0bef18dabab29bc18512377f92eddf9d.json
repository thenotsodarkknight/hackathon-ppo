{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nvar CurveProcessor = function (Class) {\n  function CurveProcessor(closed) {\n    Class.call(this);\n    this.closed = closed;\n  }\n\n  if (Class) CurveProcessor.__proto__ = Class;\n  CurveProcessor.prototype = Object.create(Class && Class.prototype);\n  CurveProcessor.prototype.constructor = CurveProcessor;\n\n  CurveProcessor.prototype.process = function process(dataPoints) {\n    var this$1 = this;\n    var points = dataPoints.slice(0);\n    var segments = [];\n    var closed = this.closed;\n    var length = points.length;\n\n    if (length > 2) {\n      this.removeDuplicates(0, points);\n      length = points.length;\n    }\n\n    if (length < 2 || length === 2 && points[0].equals(points[1])) {\n      return segments;\n    }\n\n    var p0 = points[0];\n    var p1 = points[1];\n    var p2 = points[2];\n    segments.push(new geom.Segment(p0));\n\n    while (p0.equals(points[length - 1])) {\n      closed = true;\n      points.pop();\n      length--;\n    }\n\n    if (length === 2) {\n      var tangent = this.tangent(p0, p1, X, Y);\n      last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));\n      segments.push(new geom.Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));\n      return segments;\n    }\n\n    var initialControlPoint, lastControlPoint;\n\n    if (closed) {\n      p0 = points[length - 1];\n      p1 = points[0];\n      p2 = points[1];\n      var controlPoints = this.controlPoints(p0, p1, p2);\n      initialControlPoint = controlPoints[1];\n      lastControlPoint = controlPoints[0];\n    } else {\n      var tangent$1 = this.tangent(p0, p1, X, Y);\n      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n    }\n\n    var cp0 = initialControlPoint;\n\n    for (var idx = 0; idx <= length - 3; idx++) {\n      this$1.removeDuplicates(idx, points);\n      length = points.length;\n\n      if (idx + 3 <= length) {\n        p0 = points[idx];\n        p1 = points[idx + 1];\n        p2 = points[idx + 2];\n        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);\n        last(segments).controlOut(cp0);\n        cp0 = controlPoints$1[1];\n        var cp1 = controlPoints$1[0];\n        segments.push(new geom.Segment(p1, cp1));\n      }\n    }\n\n    if (closed) {\n      p0 = points[length - 2];\n      p1 = points[length - 1];\n      p2 = points[0];\n      var controlPoints$2 = this.controlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p1, controlPoints$2[0]));\n      last(segments).controlOut(controlPoints$2[1]);\n      segments.push(new geom.Segment(p2, lastControlPoint));\n    } else {\n      var tangent$2 = this.tangent(p1, p2, X, Y);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p2, this.secondControlPoint(tangent$2, p1, p2, X, Y)));\n    }\n\n    return segments;\n  };\n\n  CurveProcessor.prototype.removeDuplicates = function removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n      points.splice(idx + 1, 1);\n    }\n  };\n\n  CurveProcessor.prototype.invertAxis = function invertAxis(p0, p1, p2) {\n    var invertAxis = false;\n\n    if (p0.x === p1.x) {\n      invertAxis = true;\n    } else if (p1.x === p2.x) {\n      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n        invertAxis = true;\n      }\n    } else {\n      var fn = this.lineFunction(p0, p1);\n      var y2 = this.calculateFunction(fn, p2.x);\n\n      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n        invertAxis = true;\n      }\n    }\n\n    return invertAxis;\n  };\n\n  CurveProcessor.prototype.isLine = function isLine(p0, p1, p2) {\n    var fn = this.lineFunction(p0, p1);\n    var y2 = this.calculateFunction(fn, p2.x);\n    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n  };\n\n  CurveProcessor.prototype.lineFunction = function lineFunction(p1, p2) {\n    var a = (p2.y - p1.y) / (p2.x - p1.x);\n    var b = p1.y - a * p1.x;\n    return [b, a];\n  };\n\n  CurveProcessor.prototype.controlPoints = function controlPoints(p0, p1, p2) {\n    var xField = X;\n    var yField = Y;\n    var restrict = false;\n    var switchOrientation = false;\n    var tangent;\n\n    if (this.isLine(p0, p1, p2)) {\n      tangent = this.tangent(p0, p1, X, Y);\n    } else {\n      var monotonic = {\n        x: this.isMonotonicByField(p0, p1, p2, X),\n        y: this.isMonotonicByField(p0, p1, p2, Y)\n      };\n\n      if (monotonic.x && monotonic.y) {\n        tangent = this.tangent(p0, p2, X, Y);\n        restrict = true;\n      } else {\n        if (this.invertAxis(p0, p1, p2)) {\n          xField = Y;\n          yField = X;\n        }\n\n        if (monotonic[xField]) {\n          tangent = 0;\n        } else {\n          var sign;\n\n          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n          } else {\n            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n          }\n\n          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n          switchOrientation = true;\n        }\n      }\n    }\n\n    var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n    if (switchOrientation) {\n      var oldXField = xField;\n      xField = yField;\n      yField = oldXField;\n    }\n\n    var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n    if (restrict) {\n      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n    }\n\n    return [secondControlPoint, firstControlPoint];\n  };\n\n  CurveProcessor.prototype.restrictControlPoint = function restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n      if (p2.y < cp.y) {\n        cp.x = p1.x + (p2.y - p1.y) / tangent;\n        cp.y = p2.y;\n      } else if (cp.y < p1.y) {\n        cp.x = p2.x - (p2.y - p1.y) / tangent;\n        cp.y = p1.y;\n      }\n    } else {\n      if (cp.y < p2.y) {\n        cp.x = p1.x - (p1.y - p2.y) / tangent;\n        cp.y = p2.y;\n      } else if (p1.y < cp.y) {\n        cp.x = p2.x + (p1.y - p2.y) / tangent;\n        cp.y = p1.y;\n      }\n    }\n  };\n\n  CurveProcessor.prototype.tangent = function tangent(p0, p1, xField, yField) {\n    var x = p1[xField] - p0[xField];\n    var y = p1[yField] - p0[yField];\n    var tangent;\n\n    if (x === 0) {\n      tangent = 0;\n    } else {\n      tangent = y / x;\n    }\n\n    return tangent;\n  };\n\n  CurveProcessor.prototype.isMonotonicByField = function isMonotonicByField(p0, p1, p2, field) {\n    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n  };\n\n  CurveProcessor.prototype.firstControlPoint = function firstControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n  };\n\n  CurveProcessor.prototype.secondControlPoint = function secondControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n  };\n\n  CurveProcessor.prototype.point = function point(xValue, yValue, xField, yField) {\n    var controlPoint = new geom.Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n    return controlPoint;\n  };\n\n  CurveProcessor.prototype.calculateFunction = function calculateFunction(fn, x) {\n    var length = fn.length;\n    var result = 0;\n\n    for (var i = 0; i < length; i++) {\n      result += Math.pow(x, i) * fn[i];\n    }\n\n    return result;\n  };\n\n  return CurveProcessor;\n}(Class);\n\nfunction numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}\n\nexport default CurveProcessor;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js"],"names":["geometry","geom","X","Y","Class","last","round","WEIGHT","EXTREMUM_ALLOWED_DEVIATION","CurveProcessor","closed","call","__proto__","prototype","Object","create","constructor","process","dataPoints","this$1","points","slice","segments","length","removeDuplicates","equals","p0","p1","p2","push","Segment","pop","tangent","controlOut","firstControlPoint","secondControlPoint","initialControlPoint","lastControlPoint","controlPoints","tangent$1","cp0","idx","controlPoints$1","cp1","controlPoints$2","tangent$2","splice","invertAxis","x","y","fn","lineFunction","y2","calculateFunction","isLine","a","b","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","sign","numberSign","oldXField","restrictControlPoint","cp","field","p3","t1","t2","distance","point","xValue","yValue","controlPoint","Point","result","i","Math","pow","value"],"mappings":"AAAA,SAASA,QAAQ,IAAIC,IAArB,QAAiC,yBAAjC;AAEA,SAASC,CAAT,EAAYC,CAAZ,QAAqB,qBAArB;AACA,SAASC,KAAT,EAAgBC,IAAhB,EAAsBC,KAAtB,QAAmC,WAAnC;AAEA,IAAIC,MAAM,GAAG,KAAb;AACA,IAAIC,0BAA0B,GAAG,IAAjC;;AAEA,IAAIC,cAAc,GAAI,UAAUL,KAAV,EAAiB;AACnC,WAASK,cAAT,CAAwBC,MAAxB,EAAgC;AAC5BN,IAAAA,KAAK,CAACO,IAAN,CAAW,IAAX;AAEA,SAAKD,MAAL,GAAcA,MAAd;AACH;;AAED,MAAKN,KAAL,EAAaK,cAAc,CAACG,SAAf,GAA2BR,KAA3B;AACbK,EAAAA,cAAc,CAACI,SAAf,GAA2BC,MAAM,CAACC,MAAP,CAAeX,KAAK,IAAIA,KAAK,CAACS,SAA9B,CAA3B;AACAJ,EAAAA,cAAc,CAACI,SAAf,CAAyBG,WAAzB,GAAuCP,cAAvC;;AAEAA,EAAAA,cAAc,CAACI,SAAf,CAAyBI,OAAzB,GAAmC,SAASA,OAAT,CAAkBC,UAAlB,EAA8B;AAC7D,QAAIC,MAAM,GAAG,IAAb;AAEA,QAAIC,MAAM,GAAGF,UAAU,CAACG,KAAX,CAAiB,CAAjB,CAAb;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIZ,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIa,MAAM,GAAGH,MAAM,CAACG,MAApB;;AAEA,QAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,WAAKC,gBAAL,CAAsB,CAAtB,EAAyBJ,MAAzB;AACAG,MAAAA,MAAM,GAAGH,MAAM,CAACG,MAAhB;AACH;;AAED,QAAIA,MAAM,GAAG,CAAT,IAAeA,MAAM,KAAK,CAAX,IAAgBH,MAAM,CAAC,CAAD,CAAN,CAAUK,MAAV,CAAiBL,MAAM,CAAC,CAAD,CAAvB,CAAnC,EAAiE;AAC7D,aAAOE,QAAP;AACH;;AAED,QAAII,EAAE,GAAGN,MAAM,CAAC,CAAD,CAAf;AACA,QAAIO,EAAE,GAAGP,MAAM,CAAC,CAAD,CAAf;AACA,QAAIQ,EAAE,GAAGR,MAAM,CAAC,CAAD,CAAf;AAEAE,IAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CAAiBJ,EAAjB,CAAd;;AAEA,WAAOA,EAAE,CAACD,MAAH,CAAUL,MAAM,CAACG,MAAM,GAAG,CAAV,CAAhB,CAAP,EAAsC;AAClCb,MAAAA,MAAM,GAAG,IAAT;AACAU,MAAAA,MAAM,CAACW,GAAP;AACAR,MAAAA,MAAM;AACT;;AAED,QAAIA,MAAM,KAAK,CAAf,EAAkB;AACd,UAAIS,OAAO,GAAG,KAAKA,OAAL,CAAaN,EAAb,EAAgBC,EAAhB,EAAoBzB,CAApB,EAAuBC,CAAvB,CAAd;AAEAE,MAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeW,UAAf,CACI,KAAKC,iBAAL,CAAuBF,OAAvB,EAAgCN,EAAhC,EAAoCC,EAApC,EAAwCzB,CAAxC,EAA2CC,CAA3C,CADJ;AAIAmB,MAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CACVH,EADU,EAEV,KAAKQ,kBAAL,CAAwBH,OAAxB,EAAiCN,EAAjC,EAAqCC,EAArC,EAAyCzB,CAAzC,EAA4CC,CAA5C,CAFU,CAAd;AAKA,aAAOmB,QAAP;AACH;;AAED,QAAIc,mBAAJ,EAAyBC,gBAAzB;;AAEA,QAAI3B,MAAJ,EAAY;AACRgB,MAAAA,EAAE,GAAGN,MAAM,CAACG,MAAM,GAAG,CAAV,CAAX;AAAyBI,MAAAA,EAAE,GAAGP,MAAM,CAAC,CAAD,CAAX;AAAgBQ,MAAAA,EAAE,GAAGR,MAAM,CAAC,CAAD,CAAX;AACzC,UAAIkB,aAAa,GAAG,KAAKA,aAAL,CAAmBZ,EAAnB,EAAuBC,EAAvB,EAA2BC,EAA3B,CAApB;AACAQ,MAAAA,mBAAmB,GAAGE,aAAa,CAAC,CAAD,CAAnC;AACAD,MAAAA,gBAAgB,GAAGC,aAAa,CAAC,CAAD,CAAhC;AACH,KALD,MAKO;AACH,UAAIC,SAAS,GAAG,KAAKP,OAAL,CAAaN,EAAb,EAAiBC,EAAjB,EAAqBzB,CAArB,EAAuBC,CAAvB,CAAhB;AACAiC,MAAAA,mBAAmB,GAAG,KAAKF,iBAAL,CAAuBK,SAAvB,EAAkCb,EAAlC,EAAsCC,EAAtC,EAA0CzB,CAA1C,EAA6CC,CAA7C,CAAtB;AACH;;AAED,QAAIqC,GAAG,GAAGJ,mBAAV;;AACA,SAAK,IAAIK,GAAG,GAAG,CAAf,EAAkBA,GAAG,IAAIlB,MAAM,GAAG,CAAlC,EAAqCkB,GAAG,EAAxC,EAA4C;AACxCtB,MAAAA,MAAM,CAACK,gBAAP,CAAwBiB,GAAxB,EAA6BrB,MAA7B;AACAG,MAAAA,MAAM,GAAGH,MAAM,CAACG,MAAhB;;AACA,UAAIkB,GAAG,GAAG,CAAN,IAAWlB,MAAf,EAAuB;AACnBG,QAAAA,EAAE,GAAGN,MAAM,CAACqB,GAAD,CAAX;AAAkBd,QAAAA,EAAE,GAAGP,MAAM,CAACqB,GAAG,GAAG,CAAP,CAAX;AAAsBb,QAAAA,EAAE,GAAGR,MAAM,CAACqB,GAAG,GAAG,CAAP,CAAX;AACxC,YAAIC,eAAe,GAAGvB,MAAM,CAACmB,aAAP,CAAqBZ,EAArB,EAAwBC,EAAxB,EAA2BC,EAA3B,CAAtB;AAEAvB,QAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeW,UAAf,CAA0BO,GAA1B;AACAA,QAAAA,GAAG,GAAGE,eAAe,CAAC,CAAD,CAArB;AAEA,YAAIC,GAAG,GAAGD,eAAe,CAAC,CAAD,CAAzB;AACApB,QAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CAAiBH,EAAjB,EAAqBgB,GAArB,CAAd;AACH;AACJ;;AAED,QAAIjC,MAAJ,EAAY;AACRgB,MAAAA,EAAE,GAAGN,MAAM,CAACG,MAAM,GAAG,CAAV,CAAX;AAAyBI,MAAAA,EAAE,GAAGP,MAAM,CAACG,MAAM,GAAG,CAAV,CAAX;AAAyBK,MAAAA,EAAE,GAAGR,MAAM,CAAC,CAAD,CAAX;AAClD,UAAIwB,eAAe,GAAG,KAAKN,aAAL,CAAmBZ,EAAnB,EAAuBC,EAAvB,EAA2BC,EAA3B,CAAtB;AAEAvB,MAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeW,UAAf,CAA0BO,GAA1B;AACAlB,MAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CACVH,EADU,EAEViB,eAAe,CAAC,CAAD,CAFL,CAAd;AAKAvC,MAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeW,UAAf,CAA0BW,eAAe,CAAC,CAAD,CAAzC;AACAtB,MAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CACVF,EADU,EAEVS,gBAFU,CAAd;AAIH,KAfD,MAeO;AACH,UAAIQ,SAAS,GAAG,KAAKb,OAAL,CAAaL,EAAb,EAAiBC,EAAjB,EAAqB1B,CAArB,EAAwBC,CAAxB,CAAhB;AAEAE,MAAAA,IAAI,CAACiB,QAAD,CAAJ,CAAeW,UAAf,CAA0BO,GAA1B;AACAlB,MAAAA,QAAQ,CAACO,IAAT,CAAc,IAAI5B,IAAI,CAAC6B,OAAT,CACVF,EADU,EAEV,KAAKO,kBAAL,CAAwBU,SAAxB,EAAmClB,EAAnC,EAAuCC,EAAvC,EAA2C1B,CAA3C,EAA8CC,CAA9C,CAFU,CAAd;AAIH;;AAED,WAAOmB,QAAP;AACH,GAlGD;;AAoGAb,EAAAA,cAAc,CAACI,SAAf,CAAyBW,gBAAzB,GAA4C,SAASA,gBAAT,CAA2BiB,GAA3B,EAAgCrB,MAAhC,EAAwC;AAChF,WAAOA,MAAM,CAACqB,GAAG,GAAG,CAAP,CAAN,KAAoBrB,MAAM,CAACqB,GAAD,CAAN,CAAYhB,MAAZ,CAAmBL,MAAM,CAACqB,GAAG,GAAG,CAAP,CAAzB,KAAuCrB,MAAM,CAACqB,GAAG,GAAG,CAAP,CAAN,CAAgBhB,MAAhB,CAAuBL,MAAM,CAACqB,GAAG,GAAG,CAAP,CAA7B,CAA3D,CAAP,EAA4G;AACxGrB,MAAAA,MAAM,CAAC0B,MAAP,CAAcL,GAAG,GAAG,CAApB,EAAuB,CAAvB;AACH;AACJ,GAJD;;AAMAhC,EAAAA,cAAc,CAACI,SAAf,CAAyBkC,UAAzB,GAAsC,SAASA,UAAT,CAAqBrB,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiC;AACnE,QAAImB,UAAU,GAAG,KAAjB;;AAEA,QAAIrB,EAAE,CAACsB,CAAH,KAASrB,EAAE,CAACqB,CAAhB,EAAmB;AACfD,MAAAA,UAAU,GAAG,IAAb;AACH,KAFD,MAEO,IAAIpB,EAAE,CAACqB,CAAH,KAASpB,EAAE,CAACoB,CAAhB,EAAmB;AACtB,UAAKrB,EAAE,CAACsB,CAAH,GAAOrB,EAAE,CAACqB,CAAV,IAAevB,EAAE,CAACuB,CAAH,IAAQtB,EAAE,CAACsB,CAA3B,IAAkCrB,EAAE,CAACqB,CAAH,GAAOtB,EAAE,CAACsB,CAAV,IAAetB,EAAE,CAACsB,CAAH,IAAQvB,EAAE,CAACuB,CAAhE,EAAoE;AAChEF,QAAAA,UAAU,GAAG,IAAb;AACH;AACJ,KAJM,MAIA;AACH,UAAIG,EAAE,GAAG,KAAKC,YAAL,CAAkBzB,EAAlB,EAAqBC,EAArB,CAAT;AACA,UAAIyB,EAAE,GAAG,KAAKC,iBAAL,CAAuBH,EAAvB,EAA2BtB,EAAE,CAACoB,CAA9B,CAAT;;AACA,UAAI,EAAEtB,EAAE,CAACuB,CAAH,IAAQtB,EAAE,CAACsB,CAAX,IAAgBrB,EAAE,CAACqB,CAAH,IAAQG,EAA1B,KACA,EAAEzB,EAAE,CAACsB,CAAH,IAAQvB,EAAE,CAACuB,CAAX,IAAgBrB,EAAE,CAACqB,CAAH,IAAQG,EAA1B,CADJ,EACmC;AAC/BL,QAAAA,UAAU,GAAG,IAAb;AACH;AACJ;;AAED,WAAOA,UAAP;AACH,GAnBD;;AAqBAtC,EAAAA,cAAc,CAACI,SAAf,CAAyByC,MAAzB,GAAkC,SAASA,MAAT,CAAiB5B,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6B;AAC3D,QAAIsB,EAAE,GAAG,KAAKC,YAAL,CAAkBzB,EAAlB,EAAsBC,EAAtB,CAAT;AACA,QAAIyB,EAAE,GAAG,KAAKC,iBAAL,CAAuBH,EAAvB,EAA2BtB,EAAE,CAACoB,CAA9B,CAAT;AAEA,WAAQtB,EAAE,CAACsB,CAAH,KAASrB,EAAE,CAACqB,CAAZ,IAAiBrB,EAAE,CAACqB,CAAH,KAASpB,EAAE,CAACoB,CAA9B,IAAoC1C,KAAK,CAAC8C,EAAD,EAAK,CAAL,CAAL,KAAiB9C,KAAK,CAACsB,EAAE,CAACqB,CAAJ,EAAO,CAAP,CAAjE;AACH,GALD;;AAOAxC,EAAAA,cAAc,CAACI,SAAf,CAAyBsC,YAAzB,GAAwC,SAASA,YAAT,CAAuBxB,EAAvB,EAA2BC,EAA3B,EAA+B;AACnE,QAAI2B,CAAC,GAAG,CAAC3B,EAAE,CAACqB,CAAH,GAAOtB,EAAE,CAACsB,CAAX,KAAiBrB,EAAE,CAACoB,CAAH,GAAOrB,EAAE,CAACqB,CAA3B,CAAR;AACA,QAAIQ,CAAC,GAAG7B,EAAE,CAACsB,CAAH,GAAOM,CAAC,GAAG5B,EAAE,CAACqB,CAAtB;AAEA,WAAO,CAAEQ,CAAF,EAAKD,CAAL,CAAP;AACH,GALD;;AAOA9C,EAAAA,cAAc,CAACI,SAAf,CAAyByB,aAAzB,GAAyC,SAASA,aAAT,CAAwBZ,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoC;AACzE,QAAI6B,MAAM,GAAGvD,CAAb;AACA,QAAIwD,MAAM,GAAGvD,CAAb;AACA,QAAIwD,QAAQ,GAAG,KAAf;AACA,QAAIC,iBAAiB,GAAG,KAAxB;AACA,QAAI5B,OAAJ;;AAEA,QAAI,KAAKsB,MAAL,CAAY5B,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB,CAAJ,EAA6B;AACzBI,MAAAA,OAAO,GAAG,KAAKA,OAAL,CAAaN,EAAb,EAAiBC,EAAjB,EAAqBzB,CAArB,EAAwBC,CAAxB,CAAV;AACH,KAFD,MAEO;AACH,UAAI0D,SAAS,GAAG;AACZb,QAAAA,CAAC,EAAE,KAAKc,kBAAL,CAAwBpC,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoC1B,CAApC,CADS;AAEZ+C,QAAAA,CAAC,EAAE,KAAKa,kBAAL,CAAwBpC,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC,EAAoCzB,CAApC;AAFS,OAAhB;;AAKA,UAAI0D,SAAS,CAACb,CAAV,IAAea,SAAS,CAACZ,CAA7B,EAAgC;AAC5BjB,QAAAA,OAAO,GAAG,KAAKA,OAAL,CAAaN,EAAb,EAAiBE,EAAjB,EAAqB1B,CAArB,EAAwBC,CAAxB,CAAV;AACAwD,QAAAA,QAAQ,GAAG,IAAX;AACH,OAHD,MAGO;AACH,YAAI,KAAKZ,UAAL,CAAgBrB,EAAhB,EAAoBC,EAApB,EAAwBC,EAAxB,CAAJ,EAAiC;AAC7B6B,UAAAA,MAAM,GAAGtD,CAAT;AACAuD,UAAAA,MAAM,GAAGxD,CAAT;AACH;;AAED,YAAI2D,SAAS,CAACJ,MAAD,CAAb,EAAuB;AACnBzB,UAAAA,OAAO,GAAG,CAAV;AACH,SAFD,MAEO;AACH,cAAI+B,IAAJ;;AACA,cAAKnC,EAAE,CAAC8B,MAAD,CAAF,GAAahC,EAAE,CAACgC,MAAD,CAAf,IAA2BhC,EAAE,CAACgC,MAAD,CAAF,IAAc/B,EAAE,CAAC+B,MAAD,CAA5C,IACChC,EAAE,CAACgC,MAAD,CAAF,GAAa9B,EAAE,CAAC8B,MAAD,CAAf,IAA2B/B,EAAE,CAAC+B,MAAD,CAAF,IAAchC,EAAE,CAACgC,MAAD,CADhD,EAC2D;AACvDK,YAAAA,IAAI,GAAGC,UAAU,CAAC,CAACpC,EAAE,CAAC8B,MAAD,CAAF,GAAahC,EAAE,CAACgC,MAAD,CAAhB,KAA6B/B,EAAE,CAAC8B,MAAD,CAAF,GAAa/B,EAAE,CAAC+B,MAAD,CAA5C,CAAD,CAAjB;AACH,WAHD,MAGO;AACHM,YAAAA,IAAI,GAAG,CAACC,UAAU,CAAC,CAACpC,EAAE,CAAC6B,MAAD,CAAF,GAAa/B,EAAE,CAAC+B,MAAD,CAAhB,KAA6B9B,EAAE,CAAC+B,MAAD,CAAF,GAAahC,EAAE,CAACgC,MAAD,CAA5C,CAAD,CAAlB;AACH;;AAED1B,UAAAA,OAAO,GAAGxB,0BAA0B,GAAGuD,IAAvC;AACAH,UAAAA,iBAAiB,GAAG,IAApB;AACH;AACJ;AACJ;;AAED,QAAIzB,kBAAkB,GAAG,KAAKA,kBAAL,CAAwBH,OAAxB,EAAiCN,EAAjC,EAAqCC,EAArC,EAAyC8B,MAAzC,EAAiDC,MAAjD,CAAzB;;AAEA,QAAIE,iBAAJ,EAAuB;AACnB,UAAIK,SAAS,GAAGR,MAAhB;AACAA,MAAAA,MAAM,GAAGC,MAAT;AACAA,MAAAA,MAAM,GAAGO,SAAT;AACH;;AAED,QAAI/B,iBAAiB,GAAG,KAAKA,iBAAL,CAAuBF,OAAvB,EAAgCL,EAAhC,EAAoCC,EAApC,EAAwC6B,MAAxC,EAAgDC,MAAhD,CAAxB;;AAEA,QAAIC,QAAJ,EAAc;AACV,WAAKO,oBAAL,CAA0BxC,EAA1B,EAA8BC,EAA9B,EAAkCQ,kBAAlC,EAAsDH,OAAtD;AACA,WAAKkC,oBAAL,CAA0BvC,EAA1B,EAA8BC,EAA9B,EAAkCM,iBAAlC,EAAqDF,OAArD;AACH;;AAED,WAAO,CAAEG,kBAAF,EAAsBD,iBAAtB,CAAP;AACH,GAzDD;;AA2DAzB,EAAAA,cAAc,CAACI,SAAf,CAAyBqD,oBAAzB,GAAgD,SAASA,oBAAT,CAA+BvC,EAA/B,EAAmCC,EAAnC,EAAuCuC,EAAvC,EAA2CnC,OAA3C,EAAoD;AAChG,QAAIL,EAAE,CAACsB,CAAH,GAAOrB,EAAE,CAACqB,CAAd,EAAiB;AACb,UAAIrB,EAAE,CAACqB,CAAH,GAAOkB,EAAE,CAAClB,CAAd,EAAiB;AACbkB,QAAAA,EAAE,CAACnB,CAAH,GAAOrB,EAAE,CAACqB,CAAH,GAAO,CAACpB,EAAE,CAACqB,CAAH,GAAOtB,EAAE,CAACsB,CAAX,IAAgBjB,OAA9B;AACAmC,QAAAA,EAAE,CAAClB,CAAH,GAAOrB,EAAE,CAACqB,CAAV;AACH,OAHD,MAGO,IAAIkB,EAAE,CAAClB,CAAH,GAAOtB,EAAE,CAACsB,CAAd,EAAiB;AACpBkB,QAAAA,EAAE,CAACnB,CAAH,GAAOpB,EAAE,CAACoB,CAAH,GAAO,CAACpB,EAAE,CAACqB,CAAH,GAAOtB,EAAE,CAACsB,CAAX,IAAgBjB,OAA9B;AACAmC,QAAAA,EAAE,CAAClB,CAAH,GAAOtB,EAAE,CAACsB,CAAV;AACH;AACJ,KARD,MAQO;AACH,UAAIkB,EAAE,CAAClB,CAAH,GAAOrB,EAAE,CAACqB,CAAd,EAAiB;AACbkB,QAAAA,EAAE,CAACnB,CAAH,GAAOrB,EAAE,CAACqB,CAAH,GAAO,CAACrB,EAAE,CAACsB,CAAH,GAAOrB,EAAE,CAACqB,CAAX,IAAgBjB,OAA9B;AACAmC,QAAAA,EAAE,CAAClB,CAAH,GAAOrB,EAAE,CAACqB,CAAV;AACH,OAHD,MAGO,IAAItB,EAAE,CAACsB,CAAH,GAAOkB,EAAE,CAAClB,CAAd,EAAiB;AACpBkB,QAAAA,EAAE,CAACnB,CAAH,GAAOpB,EAAE,CAACoB,CAAH,GAAO,CAACrB,EAAE,CAACsB,CAAH,GAAOrB,EAAE,CAACqB,CAAX,IAAgBjB,OAA9B;AACAmC,QAAAA,EAAE,CAAClB,CAAH,GAAOtB,EAAE,CAACsB,CAAV;AACH;AACJ;AACJ,GAlBD;;AAoBAxC,EAAAA,cAAc,CAACI,SAAf,CAAyBmB,OAAzB,GAAmC,SAASA,OAAT,CAAkBN,EAAlB,EAAsBC,EAAtB,EAA0B8B,MAA1B,EAAkCC,MAAlC,EAA0C;AACzE,QAAIV,CAAC,GAAGrB,EAAE,CAAC8B,MAAD,CAAF,GAAa/B,EAAE,CAAC+B,MAAD,CAAvB;AACA,QAAIR,CAAC,GAAGtB,EAAE,CAAC+B,MAAD,CAAF,GAAahC,EAAE,CAACgC,MAAD,CAAvB;AACA,QAAI1B,OAAJ;;AAEA,QAAIgB,CAAC,KAAK,CAAV,EAAa;AACThB,MAAAA,OAAO,GAAG,CAAV;AACH,KAFD,MAEO;AACHA,MAAAA,OAAO,GAAGiB,CAAC,GAAGD,CAAd;AACH;;AAED,WAAOhB,OAAP;AACH,GAZD;;AAcAvB,EAAAA,cAAc,CAACI,SAAf,CAAyBiD,kBAAzB,GAA8C,SAASA,kBAAT,CAA6BpC,EAA7B,EAAiCC,EAAjC,EAAqCC,EAArC,EAAyCwC,KAAzC,EAAgD;AAC1F,WAAQxC,EAAE,CAACwC,KAAD,CAAF,GAAYzC,EAAE,CAACyC,KAAD,CAAd,IAAyBzC,EAAE,CAACyC,KAAD,CAAF,GAAY1C,EAAE,CAAC0C,KAAD,CAAxC,IACMxC,EAAE,CAACwC,KAAD,CAAF,GAAYzC,EAAE,CAACyC,KAAD,CAAd,IAAyBzC,EAAE,CAACyC,KAAD,CAAF,GAAY1C,EAAE,CAAC0C,KAAD,CADpD;AAEH,GAHD;;AAKA3D,EAAAA,cAAc,CAACI,SAAf,CAAyBqB,iBAAzB,GAA6C,SAASA,iBAAT,CAA4BF,OAA5B,EAAqCN,EAArC,EAAyC2C,EAAzC,EAA6CZ,MAA7C,EAAqDC,MAArD,EAA6D;AACtG,QAAIY,EAAE,GAAG5C,EAAE,CAAC+B,MAAD,CAAX;AACA,QAAIc,EAAE,GAAGF,EAAE,CAACZ,MAAD,CAAX;AACA,QAAIe,QAAQ,GAAG,CAACD,EAAE,GAAGD,EAAN,IAAY/D,MAA3B;AAEA,WAAO,KAAKkE,KAAL,CAAWH,EAAE,GAAGE,QAAhB,EAA0B9C,EAAE,CAACgC,MAAD,CAAF,GAAac,QAAQ,GAAGxC,OAAlD,EAA2DyB,MAA3D,EAAmEC,MAAnE,CAAP;AACH,GAND;;AAQAjD,EAAAA,cAAc,CAACI,SAAf,CAAyBsB,kBAAzB,GAA8C,SAASA,kBAAT,CAA6BH,OAA7B,EAAsCN,EAAtC,EAA0C2C,EAA1C,EAA8CZ,MAA9C,EAAsDC,MAAtD,EAA8D;AACxG,QAAIY,EAAE,GAAG5C,EAAE,CAAC+B,MAAD,CAAX;AACA,QAAIc,EAAE,GAAGF,EAAE,CAACZ,MAAD,CAAX;AACA,QAAIe,QAAQ,GAAG,CAACD,EAAE,GAAGD,EAAN,IAAY/D,MAA3B;AAEA,WAAO,KAAKkE,KAAL,CAAWF,EAAE,GAAGC,QAAhB,EAA0BH,EAAE,CAACX,MAAD,CAAF,GAAac,QAAQ,GAAGxC,OAAlD,EAA2DyB,MAA3D,EAAmEC,MAAnE,CAAP;AACH,GAND;;AAQAjD,EAAAA,cAAc,CAACI,SAAf,CAAyB4D,KAAzB,GAAiC,SAASA,KAAT,CAAgBC,MAAhB,EAAwBC,MAAxB,EAAgClB,MAAhC,EAAwCC,MAAxC,EAAgD;AAC7E,QAAIkB,YAAY,GAAG,IAAI3E,IAAI,CAAC4E,KAAT,EAAnB;AACAD,IAAAA,YAAY,CAACnB,MAAD,CAAZ,GAAuBiB,MAAvB;AACAE,IAAAA,YAAY,CAAClB,MAAD,CAAZ,GAAuBiB,MAAvB;AAEA,WAAOC,YAAP;AACH,GAND;;AAQAnE,EAAAA,cAAc,CAACI,SAAf,CAAyBwC,iBAAzB,GAA6C,SAASA,iBAAT,CAA4BH,EAA5B,EAAgCF,CAAhC,EAAmC;AAC5E,QAAIzB,MAAM,GAAG2B,EAAE,CAAC3B,MAAhB;AACA,QAAIuD,MAAM,GAAG,CAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxD,MAApB,EAA4BwD,CAAC,EAA7B,EAAiC;AAC7BD,MAAAA,MAAM,IAAIE,IAAI,CAACC,GAAL,CAASjC,CAAT,EAAW+B,CAAX,IAAgB7B,EAAE,CAAC6B,CAAD,CAA5B;AACH;;AACD,WAAOD,MAAP;AACH,GARD;;AAUA,SAAOrE,cAAP;AACH,CA7RqB,CA6RpBL,KA7RoB,CAAtB;;AA+RA,SAAS4D,UAAT,CAAoBkB,KAApB,EAA2B;AACvB,SAAOA,KAAK,IAAI,CAAT,GAAa,CAAC,CAAd,GAAkB,CAAzB;AACH;;AAED,eAAezE,cAAf","sourcesContent":["import { geometry as geom } from '@progress/kendo-drawing';\n\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\n\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nvar CurveProcessor = (function (Class) {\n    function CurveProcessor(closed) {\n        Class.call(this);\n\n        this.closed = closed;\n    }\n\n    if ( Class ) CurveProcessor.__proto__ = Class;\n    CurveProcessor.prototype = Object.create( Class && Class.prototype );\n    CurveProcessor.prototype.constructor = CurveProcessor;\n\n    CurveProcessor.prototype.process = function process (dataPoints) {\n        var this$1 = this;\n\n        var points = dataPoints.slice(0);\n        var segments = [];\n        var closed = this.closed;\n        var length = points.length;\n\n        if (length > 2) {\n            this.removeDuplicates(0, points);\n            length = points.length;\n        }\n\n        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n            return segments;\n        }\n\n        var p0 = points[0];\n        var p1 = points[1];\n        var p2 = points[2];\n\n        segments.push(new geom.Segment(p0));\n\n        while (p0.equals(points[length - 1])) {\n            closed = true;\n            points.pop();\n            length--;\n        }\n\n        if (length === 2) {\n            var tangent = this.tangent(p0,p1, X, Y);\n\n            last(segments).controlOut(\n                this.firstControlPoint(tangent, p0, p1, X, Y)\n            );\n\n            segments.push(new geom.Segment(\n                p1,\n                this.secondControlPoint(tangent, p0, p1, X, Y)\n            ));\n\n            return segments;\n        }\n\n        var initialControlPoint, lastControlPoint;\n\n        if (closed) {\n            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n            var controlPoints = this.controlPoints(p0, p1, p2);\n            initialControlPoint = controlPoints[1];\n            lastControlPoint = controlPoints[0];\n        } else {\n            var tangent$1 = this.tangent(p0, p1, X,Y);\n            initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n        }\n\n        var cp0 = initialControlPoint;\n        for (var idx = 0; idx <= length - 3; idx++) {\n            this$1.removeDuplicates(idx, points);\n            length = points.length;\n            if (idx + 3 <= length) {\n                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                var controlPoints$1 = this$1.controlPoints(p0,p1,p2);\n\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints$1[1];\n\n                var cp1 = controlPoints$1[0];\n                segments.push(new geom.Segment(p1, cp1));\n            }\n        }\n\n        if (closed) {\n            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n            var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p1,\n                controlPoints$2[0]\n            ));\n\n            last(segments).controlOut(controlPoints$2[1]);\n            segments.push(new geom.Segment(\n                p2,\n                lastControlPoint\n            ));\n        } else {\n            var tangent$2 = this.tangent(p1, p2, X, Y);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p2,\n                this.secondControlPoint(tangent$2, p1, p2, X, Y)\n            ));\n        }\n\n        return segments;\n    };\n\n    CurveProcessor.prototype.removeDuplicates = function removeDuplicates (idx, points) {\n        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n            points.splice(idx + 1, 1);\n        }\n    };\n\n    CurveProcessor.prototype.invertAxis = function invertAxis (p0, p1, p2) {\n        var invertAxis = false;\n\n        if (p0.x === p1.x) {\n            invertAxis = true;\n        } else if (p1.x === p2.x) {\n            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                invertAxis = true;\n            }\n        } else {\n            var fn = this.lineFunction(p0,p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n            if (!(p0.y <= p1.y && p2.y <= y2) &&\n                !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n            }\n        }\n\n        return invertAxis;\n    };\n\n    CurveProcessor.prototype.isLine = function isLine (p0, p1, p2) {\n        var fn = this.lineFunction(p0, p1);\n        var y2 = this.calculateFunction(fn, p2.x);\n\n        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n    };\n\n    CurveProcessor.prototype.lineFunction = function lineFunction (p1, p2) {\n        var a = (p2.y - p1.y) / (p2.x - p1.x);\n        var b = p1.y - a * p1.x;\n\n        return [ b, a ];\n    };\n\n    CurveProcessor.prototype.controlPoints = function controlPoints (p0, p1, p2) {\n        var xField = X;\n        var yField = Y;\n        var restrict = false;\n        var switchOrientation = false;\n        var tangent;\n\n        if (this.isLine(p0, p1, p2)) {\n            tangent = this.tangent(p0, p1, X, Y);\n        } else {\n            var monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n            };\n\n            if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n            } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                    xField = Y;\n                    yField = X;\n                }\n\n                if (monotonic[xField]) {\n                    tangent = 0;\n                } else {\n                    var sign;\n                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                    } else {\n                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                    }\n\n                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                    switchOrientation = true;\n                }\n            }\n        }\n\n        var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n        if (switchOrientation) {\n            var oldXField = xField;\n            xField = yField;\n            yField = oldXField;\n        }\n\n        var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n        if (restrict) {\n            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n        }\n\n        return [ secondControlPoint, firstControlPoint ];\n    };\n\n    CurveProcessor.prototype.restrictControlPoint = function restrictControlPoint (p1, p2, cp, tangent) {\n        if (p1.y < p2.y) {\n            if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n            } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n            }\n        } else {\n            if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n            } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n            }\n        }\n    };\n\n    CurveProcessor.prototype.tangent = function tangent (p0, p1, xField, yField) {\n        var x = p1[xField] - p0[xField];\n        var y = p1[yField] - p0[yField];\n        var tangent;\n\n        if (x === 0) {\n            tangent = 0;\n        } else {\n            tangent = y / x;\n        }\n\n        return tangent;\n    };\n\n    CurveProcessor.prototype.isMonotonicByField = function isMonotonicByField (p0, p1, p2, field) {\n        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                    (p2[field] < p1[field] && p1[field] < p0[field]);\n    };\n\n    CurveProcessor.prototype.firstControlPoint = function firstControlPoint (tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n    };\n\n    CurveProcessor.prototype.secondControlPoint = function secondControlPoint (tangent, p0, p3, xField, yField) {\n        var t1 = p0[xField];\n        var t2 = p3[xField];\n        var distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n    };\n\n    CurveProcessor.prototype.point = function point (xValue, yValue, xField, yField) {\n        var controlPoint = new geom.Point();\n        controlPoint[xField] = xValue;\n        controlPoint[yField] = yValue;\n\n        return controlPoint;\n    };\n\n    CurveProcessor.prototype.calculateFunction = function calculateFunction (fn, x) {\n        var length = fn.length;\n        var result = 0;\n\n        for (var i = 0; i < length; i++) {\n            result += Math.pow(x,i) * fn[i];\n        }\n        return result;\n    };\n\n    return CurveProcessor;\n}(Class));\n\nfunction numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n\nexport default CurveProcessor;"]},"metadata":{},"sourceType":"module"}