{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = function (ChartElement) {\n  function Axis(options, chartService) {\n    if (chartService === void 0) chartService = new ChartService();\n    ChartElement.call(this, options);\n    this.chartService = chartService;\n\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n\n    this.createTitle();\n    this.createNotes();\n  }\n\n  if (ChartElement) Axis.__proto__ = ChartElement;\n  Axis.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Axis.prototype.constructor = Axis;\n\n  Axis.prototype.initFields = function initFields() {}; // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n\n  Axis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  };\n\n  Axis.prototype.createLabels = function createLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var align = options.vertical ? RIGHT : CENTER;\n    var labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    var step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n\n    if (labelOptions.visible) {\n      var range = this.labelsRange();\n      var rotation = labelOptions.rotation;\n\n      if (isObject(rotation)) {\n        labelOptions.alignRotation = rotation.align;\n        labelOptions.rotation = rotation.angle;\n      }\n\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n\n      for (var idx = range.min; idx < range.max; idx += step) {\n        var label = this$1.createAxisLabel(idx, labelOptions);\n\n        if (label) {\n          this$1.append(label);\n          this$1.labels.push(label);\n        }\n      }\n    }\n  };\n\n  Axis.prototype.clearLabels = function clearLabels() {\n    this.children = grep(this.children, function (child) {\n      return !(child instanceof AxisLabel);\n    });\n    this.labels = [];\n  };\n\n  Axis.prototype.clearTitle = function clearTitle() {\n    var this$1 = this;\n\n    if (this.title) {\n      this.children = grep(this.children, function (child) {\n        return child !== this$1.title;\n      });\n      this.title = undefined;\n    }\n  };\n\n  Axis.prototype.clear = function clear() {\n    this.clearLabels();\n    this.clearTitle();\n  };\n\n  Axis.prototype.lineBox = function lineBox() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var axisX = mirror ? box.x1 : box.x2;\n    var axisY = mirror ? box.y2 : box.y1;\n    var lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  };\n\n  Axis.prototype.createTitle = function createTitle() {\n    var options = this.options;\n    var titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n\n    if (titleOptions.visible && titleOptions.text) {\n      var title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  };\n\n  Axis.prototype.createNotes = function createNotes() {\n    var this$1 = this;\n    var options = this.options;\n    var notes = options.notes;\n    var items = notes.data || [];\n    this.notes = [];\n\n    for (var i = 0; i < items.length; i++) {\n      var item = deepExtend({}, notes, items[i]);\n      item.value = this$1.parseNoteValue(item.value);\n      var note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this$1.chartService);\n\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n\n        this$1.append(note);\n        this$1.notes.push(note);\n      }\n    }\n  };\n\n  Axis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return value;\n  };\n\n  Axis.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    this.createPlotBands();\n  };\n\n  Axis.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    this.createBackground();\n    this.createLine();\n  };\n\n  Axis.prototype.gridLinesVisual = function gridLinesVisual() {\n    var gridLines = this._gridLines;\n\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n\n    return gridLines;\n  };\n\n  Axis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n\n    function render(tickPositions, tickOptions, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, tickOptions.step);\n\n      if (tickOptions.visible) {\n        for (var i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  };\n\n  Axis.prototype.createLine = function createLine() {\n    var options = this.options;\n    var line = options.line;\n    var lineBox = this.lineBox();\n\n    if (line.width > 0 && line.visible) {\n      var path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n        /* TODO\n        zIndex: line.zIndex,\n        */\n\n      });\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n\n      var group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  };\n\n  Axis.prototype.getActualTickSize = function getActualTickSize() {\n    var options = this.options;\n    var tickSize = 0;\n\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n\n    return tickSize;\n  };\n\n  Axis.prototype.createBackground = function createBackground() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var background = options.background;\n\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  };\n\n  Axis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var options = this.options;\n    var plotBands = options.plotBands || [];\n    var vertical = options.vertical;\n    var plotArea = this.plotArea;\n\n    if (plotBands.length === 0) {\n      return;\n    }\n\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    var altAxis = grep(this.pane.axes, function (axis) {\n      return axis.options.vertical !== this$1.options.vertical;\n    })[0];\n\n    for (var idx = 0; idx < plotBands.length; idx++) {\n      var item = plotBands[idx];\n      var slotX = void 0,\n          slotY = void 0;\n\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this$1.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this$1.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        var bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        var path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n      }\n    }\n\n    this.appendVisual(group);\n  };\n\n  Axis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var minorUnit = options.minorUnit;\n    var vertical = options.vertical;\n    var axisLineVisible = altAxis.options.line.visible;\n    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    var lineBox = altAxis.lineBox();\n    var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n\n    function render(tickPositions, gridLine, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, gridLine.step);\n\n      if (gridLine.visible) {\n        for (var i = gridLine.skip; i < count; i += step) {\n          var pos = round(tickPositions[i]);\n\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  };\n\n  Axis.prototype.reflow = function reflow(box) {\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var title = ref.title;\n    var vertical = options.vertical;\n    var count = labels.length;\n    var sizeFn = vertical ? WIDTH : HEIGHT;\n    var titleSize = title ? title.box[sizeFn]() : 0;\n    var space = this.getActualTickSize() + options.margin + titleSize;\n    var rootBox = (this.getRoot() || {}).box || box;\n    var boxSize = rootBox[sizeFn]();\n    var maxLabelSize = 0;\n\n    for (var i = 0; i < count; i++) {\n      var labelSize = labels[i].box[sizeFn]();\n\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  };\n\n  Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  };\n\n  Axis.prototype.labelTickIndex = function labelTickIndex(label) {\n    return label.index;\n  };\n\n  Axis.prototype.arrangeLabels = function arrangeLabels() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var tickPositions = this.getLabelsTickPositions();\n    var labelOffset = this.getActualTickSize() + options.margin;\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var labelSize = vertical ? label.box.height() : label.box.width();\n      var labelPos = tickPositions[tickIx] - labelSize / 2;\n      var labelBox = void 0,\n          firstTickPosition = void 0,\n          nextTickPosition = void 0;\n\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          firstTickPosition = tickPositions[tickIx];\n          nextTickPosition = tickPositions[tickIx + 1];\n          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          labelPos = middle - labelSize / 2;\n        }\n\n        var labelX = lineBox.x2;\n\n        if (mirror) {\n          labelX += labelOffset;\n          label.options.rotationOrigin = LEFT;\n        } else {\n          labelX -= labelOffset + label.box.width();\n          label.options.rotationOrigin = RIGHT;\n        }\n\n        labelBox = label.box.move(labelX, labelPos);\n      } else {\n        if (labelsBetweenTicks) {\n          firstTickPosition = tickPositions[tickIx];\n          nextTickPosition = tickPositions[tickIx + 1];\n        } else {\n          firstTickPosition = labelPos;\n          nextTickPosition = labelPos + labelSize;\n        }\n\n        var labelY = lineBox.y1;\n\n        if (mirror) {\n          labelY -= labelOffset + label.box.height();\n          label.options.rotationOrigin = BOTTOM;\n        } else {\n          labelY += labelOffset;\n          label.options.rotationOrigin = TOP;\n        }\n\n        labelBox = new Box(firstTickPosition, labelY, nextTickPosition, labelY + label.box.height());\n      }\n\n      label.reflow(labelBox);\n    }\n  };\n\n  Axis.prototype.autoRotateLabels = function autoRotateLabels() {\n    if (this.options.autoRotateLabels && !this.options.vertical) {\n      var tickPositions = this.getMajorTickPositions();\n      var labels = this.labels;\n      var angle;\n\n      for (var idx = 0; idx < labels.length; idx++) {\n        var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n        var labelBox = labels[idx].box;\n\n        if (labelBox.width() > width) {\n          if (labelBox.height() > width) {\n            angle = -90;\n            break;\n          }\n\n          angle = -45;\n        }\n      }\n\n      if (angle) {\n        for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n          labels[idx$1].options.rotation = angle;\n          labels[idx$1].reflow(new Box());\n        }\n\n        return true;\n      }\n    }\n  };\n\n  Axis.prototype.arrangeTitle = function arrangeTitle() {\n    var ref = this;\n    var options = ref.options;\n    var title = ref.title;\n    var mirror = options.labels.mirror;\n    var vertical = options.vertical;\n\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n\n      title.reflow(this.box);\n    }\n  };\n\n  Axis.prototype.arrangeNotes = function arrangeNotes() {\n    var this$1 = this;\n\n    for (var idx = 0; idx < this.notes.length; idx++) {\n      var item = this$1.notes[idx];\n      var value = item.options.value;\n      var slot = void 0;\n\n      if (defined(value)) {\n        if (this$1.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n\n        slot = this$1.noteSlot(value);\n      } else {\n        item.hide();\n      }\n\n      item.reflow(slot || this$1.lineBox());\n    }\n  };\n\n  Axis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n\n  Axis.prototype.alignTo = function alignTo(secondAxis) {\n    var lineBox = secondAxis.lineBox();\n    var vertical = this.options.vertical;\n    var pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  };\n\n  Axis.prototype.axisLabelText = function axisLabelText(value, dataItem, options) {\n    var tmpl = getTemplate(options);\n    var text = value;\n\n    if (tmpl) {\n      text = tmpl({\n        value: value,\n        dataItem: dataItem,\n        format: options.format,\n        culture: options.culture\n      });\n    } else if (options.format) {\n      text = this.chartService.format.localeAuto(options.format, [value], options.culture);\n    }\n\n    return text;\n  };\n\n  Axis.prototype.slot = function slot(from, to, limit) {\n    var slot = this.getSlot(from, to, limit);\n\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n\n  Axis.prototype.contentBox = function contentBox() {\n    var box = this.box.clone();\n    var labels = this.labels;\n\n    if (labels.length) {\n      var axis = this.options.vertical ? Y : X;\n\n      if (this.chartService.isPannable(axis)) {\n        var offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n\n        var lastLabel = labels[labels.length - 1];\n\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n\n    return box;\n  };\n\n  Axis.prototype.maxLabelOffset = function maxLabelOffset() {\n    var this$1 = this;\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var tickPositions = this.getLabelsTickPositions();\n    var offsetField = vertical ? Y : X;\n    var labels = this.labels;\n    var startPosition = reverse ? 1 : 0;\n    var endPosition = reverse ? 0 : 1;\n    var maxStartOffset = 0;\n    var maxEndOffset = 0;\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var startTick = void 0,\n          endTick = void 0;\n\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  };\n\n  Axis.prototype.limitRange = function limitRange(from, to, min, max, offset) {\n    var options = this.options;\n\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n\n    var rangeSize = to - from;\n    var minValue = from;\n    var maxValue = to;\n\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  };\n\n  Axis.prototype.valueRange = function valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  };\n\n  Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.options.justified;\n  }; //add legacy fields to the options that are no longer generated by default\n\n\n  Axis.prototype.prepareUserOptions = function prepareUserOptions() {};\n\n  return Axis;\n}(ChartElement);\n\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/core/axis.js"],"names":["drawing","draw","geometry","geom","ChartElement","TextBox","AxisLabel","Note","Box","ChartService","createAxisTick","createAxisGridLine","NONE","BLACK","CENTER","TOP","BOTTOM","LEFT","RIGHT","OUTSIDE","X","Y","WIDTH","HEIGHT","alignPathToPixel","deepExtend","getTemplate","grep","defined","isObject","inArray","limitValue","round","setDefaultOptions","Axis","options","chartService","call","visible","labels","line","margin","majorTickSize","minorTickSize","minorTicks","color","width","minorTickType","size","align","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","__proto__","prototype","Object","create","constructor","labelsRange","min","skip","max","labelsCount","this$1","vertical","labelOptions","zIndex","step","Math","clearLabels","range","rotation","alignRotation","angle","autoRotateLabels","idx","label","createAxisLabel","append","push","children","child","clearTitle","title","undefined","clear","lineBox","ref","box","mirror","axisX","x1","x2","axisY","y2","y1","lineWidth","titleOptions","text","visualSize","notes","items","data","i","length","item","value","parseNoteValue","note","dataItem","position","reverse","renderVisual","createPlotBands","createVisual","createBackground","createLine","gridLinesVisual","gridLines","_gridLines","Group","appendVisual","createTicks","lineGroup","majorUnit","tickLineOptions","render","tickPositions","tickOptions","skipUnit","count","tickX","tickY","getMajorTickPositions","getMinorTickPositions","minorUnit","path","Path","stroke","dashType","moveTo","lineTo","_alignLines","group","_lineGroup","visual","getActualTickSize","tickSize","background","_backgroundPath","fromRect","toRect","fill","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","axis","slotX","slotY","getSlot","from","to","height","bandRect","Rect","opacity","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","lineStart","lineEnd","container","gridLine","pos","reflow","sizeFn","titleSize","space","rootBox","getRoot","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","index","labelsBetweenTicks","labelOffset","tickIx","labelPos","labelBox","firstTickPosition","nextTickPosition","middle","labelX","rotationOrigin","move","labelY","abs","idx$1","vAlign","slot","shouldRenderNote","show","hide","noteSlot","alignTo","secondAxis","snapTo","shrink","axisLabelText","tmpl","format","culture","localeAuto","limit","contentBox","clone","isPannable","offset","maxLabelOffset","start","end","wrap","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","justified","prepareUserOptions","axisCrossingValue"],"mappings":"AAAA,SAASA,OAAO,IAAIC,IAApB,EAA0BC,QAAQ,IAAIC,IAAtC,QAAkD,yBAAlD;AAEA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,SAASC,YAAT,QAA6B,aAA7B;AAEA,OAAOC,cAAP,MAA2B,0BAA3B;AACA,OAAOC,kBAAP,MAA+B,+BAA/B;AAEA,SAASC,IAAT,EAAeC,KAAf,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,MAAnC,EAA2CC,IAA3C,EAAiDC,KAAjD,EAAwDC,OAAxD,EAAiEC,CAAjE,EAAoEC,CAApE,EAAuEC,KAAvE,EAA8EC,MAA9E,QAA4F,qBAA5F;AACA,SAASC,gBAAT,EAA2BC,UAA3B,EAAuCC,WAAvC,EAAoDC,IAApD,EAA0DC,OAA1D,EAAmEC,QAAnE,EAA6EC,OAA7E,EAAsFC,UAAtF,EAAkGC,KAAlG,EAAyGC,iBAAzG,QAAkI,WAAlI;;AAEA,IAAIC,IAAI,GAAI,UAAU9B,YAAV,EAAwB;AAChC,WAAS8B,IAAT,CAAcC,OAAd,EAAuBC,YAAvB,EAAqC;AACjC,QAAKA,YAAY,KAAK,KAAK,CAA3B,EAA+BA,YAAY,GAAG,IAAI3B,YAAJ,EAAf;AAE/BL,IAAAA,YAAY,CAACiC,IAAb,CAAkB,IAAlB,EAAwBF,OAAxB;AAEA,SAAKC,YAAL,GAAoBA,YAApB;;AAEA,QAAI,CAAC,KAAKD,OAAL,CAAaG,OAAlB,EAA2B;AACvB,WAAKH,OAAL,GAAeV,UAAU,CAAC,EAAD,EAAK,KAAKU,OAAV,EAAmB;AACxCI,QAAAA,MAAM,EAAE;AACJD,UAAAA,OAAO,EAAE;AADL,SADgC;AAIxCE,QAAAA,IAAI,EAAE;AACFF,UAAAA,OAAO,EAAE;AADP,SAJkC;AAOxCG,QAAAA,MAAM,EAAE,CAPgC;AAQxCC,QAAAA,aAAa,EAAE,CARyB;AASxCC,QAAAA,aAAa,EAAE;AATyB,OAAnB,CAAzB;AAWH;;AAED,SAAKR,OAAL,CAAaS,UAAb,GAA0BnB,UAAU,CAAC,EAAD,EAAK;AACrCoB,MAAAA,KAAK,EAAE,KAAKV,OAAL,CAAaK,IAAb,CAAkBK,KADY;AAErCC,MAAAA,KAAK,EAAE,KAAKX,OAAL,CAAaK,IAAb,CAAkBM,KAFY;AAGrCR,MAAAA,OAAO,EAAE,KAAKH,OAAL,CAAaY,aAAb,KAA+BnC;AAHH,KAAL,EAIjC,KAAKuB,OAAL,CAAaS,UAJoB,EAIR;AACxBI,MAAAA,IAAI,EAAE,KAAKb,OAAL,CAAaQ,aADK;AAExBM,MAAAA,KAAK,EAAE,KAAKd,OAAL,CAAaY;AAFI,KAJQ,CAApC;AASA,SAAKZ,OAAL,CAAae,UAAb,GAA0BzB,UAAU,CAAC,EAAD,EAAK;AACrCoB,MAAAA,KAAK,EAAE,KAAKV,OAAL,CAAaK,IAAb,CAAkBK,KADY;AAErCC,MAAAA,KAAK,EAAE,KAAKX,OAAL,CAAaK,IAAb,CAAkBM,KAFY;AAGrCR,MAAAA,OAAO,EAAE,KAAKH,OAAL,CAAagB,aAAb,KAA+BvC;AAHH,KAAL,EAIjC,KAAKuB,OAAL,CAAae,UAJoB,EAIR;AACxBF,MAAAA,IAAI,EAAE,KAAKb,OAAL,CAAaO,aADK;AAExBO,MAAAA,KAAK,EAAE,KAAKd,OAAL,CAAagB;AAFI,KAJQ,CAApC;AASA,SAAKC,UAAL;;AAEA,QAAI,CAAC,KAAKjB,OAAL,CAAakB,YAAlB,EAAgC;AAC5B,WAAKC,YAAL;AACH;;AAED,SAAKC,WAAL;AACA,SAAKC,WAAL;AACH;;AAED,MAAKpD,YAAL,EAAoB8B,IAAI,CAACuB,SAAL,GAAiBrD,YAAjB;AACpB8B,EAAAA,IAAI,CAACwB,SAAL,GAAiBC,MAAM,CAACC,MAAP,CAAexD,YAAY,IAAIA,YAAY,CAACsD,SAA5C,CAAjB;AACAxB,EAAAA,IAAI,CAACwB,SAAL,CAAeG,WAAf,GAA6B3B,IAA7B;;AAEAA,EAAAA,IAAI,CAACwB,SAAL,CAAeN,UAAf,GAA4B,SAASA,UAAT,GAAuB,CAClD,CADD,CAtDgC,CAyDhC;AACA;;;AAEAlB,EAAAA,IAAI,CAACwB,SAAL,CAAeI,WAAf,GAA6B,SAASA,WAAT,GAAwB;AACjD,WAAO;AACHC,MAAAA,GAAG,EAAE,KAAK5B,OAAL,CAAaI,MAAb,CAAoByB,IADtB;AAEHC,MAAAA,GAAG,EAAE,KAAKC,WAAL;AAFF,KAAP;AAIH,GALD;;AAOAhC,EAAAA,IAAI,CAACwB,SAAL,CAAeJ,YAAf,GAA8B,SAASA,YAAT,GAAyB;AACnD,QAAIa,MAAM,GAAG,IAAb;AAEA,QAAIhC,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIc,KAAK,GAAGd,OAAO,CAACiC,QAAR,GAAmBlD,KAAnB,GAA2BJ,MAAvC;AACA,QAAIuD,YAAY,GAAG5C,UAAU,CAAC,EAAD,EAAMU,OAAO,CAACI,MAAd,EAAsB;AAC/CU,MAAAA,KAAK,EAAEA,KADwC;AAE/CqB,MAAAA,MAAM,EAAEnC,OAAO,CAACmC;AAF+B,KAAtB,CAA7B;AAIA,QAAIC,IAAI,GAAGC,IAAI,CAACP,GAAL,CAAS,CAAT,EAAYI,YAAY,CAACE,IAAzB,CAAX;AAEA,SAAKE,WAAL;;AAEA,QAAIJ,YAAY,CAAC/B,OAAjB,EAA0B;AACtB,UAAIoC,KAAK,GAAG,KAAKZ,WAAL,EAAZ;AACA,UAAIa,QAAQ,GAAGN,YAAY,CAACM,QAA5B;;AAEA,UAAI9C,QAAQ,CAAC8C,QAAD,CAAZ,EAAwB;AACpBN,QAAAA,YAAY,CAACO,aAAb,GAA6BD,QAAQ,CAAC1B,KAAtC;AACAoB,QAAAA,YAAY,CAACM,QAAb,GAAwBA,QAAQ,CAACE,KAAjC;AACH;;AAED,UAAIR,YAAY,CAACM,QAAb,KAA0B,MAA9B,EAAsC;AAClCN,QAAAA,YAAY,CAACM,QAAb,GAAwB,CAAxB;AACAxC,QAAAA,OAAO,CAAC2C,gBAAR,GAA2B,IAA3B;AACH;;AAED,WAAK,IAAIC,GAAG,GAAGL,KAAK,CAACX,GAArB,EAA0BgB,GAAG,GAAGL,KAAK,CAACT,GAAtC,EAA2Cc,GAAG,IAAIR,IAAlD,EAAwD;AACpD,YAAIS,KAAK,GAAGb,MAAM,CAACc,eAAP,CAAuBF,GAAvB,EAA4BV,YAA5B,CAAZ;;AACA,YAAIW,KAAJ,EAAW;AACPb,UAAAA,MAAM,CAACe,MAAP,CAAcF,KAAd;AACAb,UAAAA,MAAM,CAAC5B,MAAP,CAAc4C,IAAd,CAAmBH,KAAnB;AACH;AACJ;AACJ;AACJ,GAnCD;;AAqCA9C,EAAAA,IAAI,CAACwB,SAAL,CAAee,WAAf,GAA6B,SAASA,WAAT,GAAwB;AACjD,SAAKW,QAAL,GAAgBzD,IAAI,CAAC,KAAKyD,QAAN,EAAgB,UAAUC,KAAV,EAAiB;AAAE,aAAO,EAAEA,KAAK,YAAY/E,SAAnB,CAAP;AAAuC,KAA1E,CAApB;AACA,SAAKiC,MAAL,GAAc,EAAd;AACH,GAHD;;AAKAL,EAAAA,IAAI,CAACwB,SAAL,CAAe4B,UAAf,GAA4B,SAASA,UAAT,GAAuB;AAC/C,QAAInB,MAAM,GAAG,IAAb;;AAEA,QAAI,KAAKoB,KAAT,EAAgB;AACZ,WAAKH,QAAL,GAAgBzD,IAAI,CAAC,KAAKyD,QAAN,EAAgB,UAAUC,KAAV,EAAiB;AAAE,eAAOA,KAAK,KAAKlB,MAAM,CAACoB,KAAxB;AAAgC,OAAnE,CAApB;AACA,WAAKA,KAAL,GAAaC,SAAb;AACH;AACJ,GAPD;;AASAtD,EAAAA,IAAI,CAACwB,SAAL,CAAe+B,KAAf,GAAuB,SAASA,KAAT,GAAkB;AACrC,SAAKhB,WAAL;AACA,SAAKa,UAAL;AACH,GAHD;;AAKApD,EAAAA,IAAI,CAACwB,SAAL,CAAegC,OAAf,GAAyB,SAASA,OAAT,GAAoB;AACzC,QAAIC,GAAG,GAAG,IAAV;AACA,QAAIxD,OAAO,GAAGwD,GAAG,CAACxD,OAAlB;AACA,QAAIyD,GAAG,GAAGD,GAAG,CAACC,GAAd;AACA,QAAIxB,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;AACA,QAAIyB,MAAM,GAAG1D,OAAO,CAACI,MAAR,CAAesD,MAA5B;AACA,QAAIC,KAAK,GAAGD,MAAM,GAAGD,GAAG,CAACG,EAAP,GAAYH,GAAG,CAACI,EAAlC;AACA,QAAIC,KAAK,GAAGJ,MAAM,GAAGD,GAAG,CAACM,EAAP,GAAYN,GAAG,CAACO,EAAlC;AACA,QAAIC,SAAS,GAAGjE,OAAO,CAACK,IAAR,CAAaM,KAAb,IAAsB,CAAtC;AAEA,WAAOsB,QAAQ,GACX,IAAI5D,GAAJ,CAAQsF,KAAR,EAAeF,GAAG,CAACO,EAAnB,EAAuBL,KAAvB,EAA8BF,GAAG,CAACM,EAAJ,GAASE,SAAvC,CADW,GAEX,IAAI5F,GAAJ,CAAQoF,GAAG,CAACG,EAAZ,EAAgBE,KAAhB,EAAuBL,GAAG,CAACI,EAAJ,GAASI,SAAhC,EAA2CH,KAA3C,CAFJ;AAGH,GAbD;;AAeA/D,EAAAA,IAAI,CAACwB,SAAL,CAAeH,WAAf,GAA6B,SAASA,WAAT,GAAwB;AACjD,QAAIpB,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIkE,YAAY,GAAG5E,UAAU,CAAC;AAC1BkD,MAAAA,QAAQ,EAAExC,OAAO,CAACiC,QAAR,GAAmB,CAAC,EAApB,GAAyB,CADT;AAE1BkC,MAAAA,IAAI,EAAE,EAFoB;AAG1BhC,MAAAA,MAAM,EAAE,CAHkB;AAI1BiC,MAAAA,UAAU,EAAE;AAJc,KAAD,EAK1BpE,OAAO,CAACoD,KALkB,CAA7B;;AAOA,QAAIc,YAAY,CAAC/D,OAAb,IAAwB+D,YAAY,CAACC,IAAzC,EAA+C;AAC3C,UAAIf,KAAK,GAAG,IAAIlF,OAAJ,CAAYgG,YAAY,CAACC,IAAzB,EAA+BD,YAA/B,CAAZ;AACA,WAAKnB,MAAL,CAAYK,KAAZ;AACA,WAAKA,KAAL,GAAaA,KAAb;AACH;AACJ,GAdD;;AAgBArD,EAAAA,IAAI,CAACwB,SAAL,CAAeF,WAAf,GAA6B,SAASA,WAAT,GAAwB;AACjD,QAAIW,MAAM,GAAG,IAAb;AAEA,QAAIhC,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIqE,KAAK,GAAGrE,OAAO,CAACqE,KAApB;AACA,QAAIC,KAAK,GAAGD,KAAK,CAACE,IAAN,IAAc,EAA1B;AAEA,SAAKF,KAAL,GAAa,EAAb;;AAEA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnC,UAAIE,IAAI,GAAGpF,UAAU,CAAC,EAAD,EAAK+E,KAAL,EAAYC,KAAK,CAACE,CAAD,CAAjB,CAArB;AACAE,MAAAA,IAAI,CAACC,KAAL,GAAa3C,MAAM,CAAC4C,cAAP,CAAsBF,IAAI,CAACC,KAA3B,CAAb;AAEA,UAAIE,IAAI,GAAG,IAAIzG,IAAJ,CAAS;AAChBuG,QAAAA,KAAK,EAAED,IAAI,CAACC,KADI;AAEhBR,QAAAA,IAAI,EAAEO,IAAI,CAAC7B,KAAL,CAAWsB,IAFD;AAGhBW,QAAAA,QAAQ,EAAEJ;AAHM,OAAT,EAIRA,IAJQ,EAIF1C,MAAM,CAAC/B,YAJL,CAAX;;AAMA,UAAI4E,IAAI,CAAC7E,OAAL,CAAaG,OAAjB,EAA0B;AACtB,YAAIV,OAAO,CAACoF,IAAI,CAAC7E,OAAL,CAAa+E,QAAd,CAAX,EAAoC;AAChC,cAAI/E,OAAO,CAACiC,QAAR,IAAoB,CAACtC,OAAO,CAACkF,IAAI,CAAC7E,OAAL,CAAa+E,QAAd,EAAwB,CAAEjG,IAAF,EAAQC,KAAR,CAAxB,CAAhC,EAA0E;AACtE8F,YAAAA,IAAI,CAAC7E,OAAL,CAAa+E,QAAb,GAAwB/E,OAAO,CAACgF,OAAR,GAAkBlG,IAAlB,GAAyBC,KAAjD;AACH,WAFD,MAEO,IAAI,CAACiB,OAAO,CAACiC,QAAT,IAAqB,CAACtC,OAAO,CAACkF,IAAI,CAAC7E,OAAL,CAAa+E,QAAd,EAAwB,CAAEnG,GAAF,EAAOC,MAAP,CAAxB,CAAjC,EAA2E;AAC9EgG,YAAAA,IAAI,CAAC7E,OAAL,CAAa+E,QAAb,GAAwB/E,OAAO,CAACgF,OAAR,GAAkBnG,MAAlB,GAA2BD,GAAnD;AACH;AACJ,SAND,MAMO;AACH,cAAIoB,OAAO,CAACiC,QAAZ,EAAsB;AAClB4C,YAAAA,IAAI,CAAC7E,OAAL,CAAa+E,QAAb,GAAwB/E,OAAO,CAACgF,OAAR,GAAkBlG,IAAlB,GAAyBC,KAAjD;AACH,WAFD,MAEO;AACH8F,YAAAA,IAAI,CAAC7E,OAAL,CAAa+E,QAAb,GAAwB/E,OAAO,CAACgF,OAAR,GAAkBnG,MAAlB,GAA2BD,GAAnD;AACH;AACJ;;AACDoD,QAAAA,MAAM,CAACe,MAAP,CAAc8B,IAAd;AACA7C,QAAAA,MAAM,CAACqC,KAAP,CAAarB,IAAb,CAAkB6B,IAAlB;AACH;AACJ;AACJ,GArCD;;AAuCA9E,EAAAA,IAAI,CAACwB,SAAL,CAAeqD,cAAf,GAAgC,SAASA,cAAT,CAAyBD,KAAzB,EAAgC;AAC5D,WAAOA,KAAP;AACH,GAFD;;AAIA5E,EAAAA,IAAI,CAACwB,SAAL,CAAe0D,YAAf,GAA8B,SAASA,YAAT,GAAyB;AACnDhH,IAAAA,YAAY,CAACsD,SAAb,CAAuB0D,YAAvB,CAAoC/E,IAApC,CAAyC,IAAzC;AAEA,SAAKgF,eAAL;AACH,GAJD;;AAMAnF,EAAAA,IAAI,CAACwB,SAAL,CAAe4D,YAAf,GAA8B,SAASA,YAAT,GAAyB;AACnDlH,IAAAA,YAAY,CAACsD,SAAb,CAAuB4D,YAAvB,CAAoCjF,IAApC,CAAyC,IAAzC;AAEA,SAAKkF,gBAAL;AACA,SAAKC,UAAL;AACH,GALD;;AAOAtF,EAAAA,IAAI,CAACwB,SAAL,CAAe+D,eAAf,GAAiC,SAASA,eAAT,GAA4B;AACzD,QAAIC,SAAS,GAAG,KAAKC,UAArB;;AACA,QAAI,CAACD,SAAL,EAAgB;AACZA,MAAAA,SAAS,GAAG,KAAKC,UAAL,GAAkB,IAAI1H,IAAI,CAAC2H,KAAT,CAAe;AACzCtD,QAAAA,MAAM,EAAE,CAAC;AADgC,OAAf,CAA9B;AAGA,WAAKuD,YAAL,CAAkB,KAAKF,UAAvB;AACH;;AAED,WAAOD,SAAP;AACH,GAVD;;AAYAxF,EAAAA,IAAI,CAACwB,SAAL,CAAeoE,WAAf,GAA6B,SAASA,WAAT,CAAsBC,SAAtB,EAAiC;AAC1D,QAAI5F,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIuD,OAAO,GAAG,KAAKA,OAAL,EAAd;AACA,QAAIG,MAAM,GAAG1D,OAAO,CAACI,MAAR,CAAesD,MAA5B;AACA,QAAImC,SAAS,GAAG7F,OAAO,CAACe,UAAR,CAAmBZ,OAAnB,GAA6BH,OAAO,CAAC6F,SAArC,GAAiD,CAAjE;AACA,QAAIC,eAAe,GAAG;AAClB;AACA;AACA7D,MAAAA,QAAQ,EAAEjC,OAAO,CAACiC;AAHA,KAAtB;;AAMA,aAAS8D,MAAT,CAAgBC,aAAhB,EAA+BC,WAA/B,EAA4CC,QAA5C,EAAsD;AAClD,UAAIC,KAAK,GAAGH,aAAa,CAACvB,MAA1B;AACA,UAAIrC,IAAI,GAAGC,IAAI,CAACP,GAAL,CAAS,CAAT,EAAYmE,WAAW,CAAC7D,IAAxB,CAAX;;AAEA,UAAI6D,WAAW,CAAC9F,OAAhB,EAAyB;AACrB,aAAK,IAAIqE,CAAC,GAAGyB,WAAW,CAACpE,IAAzB,EAA+B2C,CAAC,GAAG2B,KAAnC,EAA0C3B,CAAC,IAAIpC,IAA/C,EAAqD;AACjD,cAAI3C,OAAO,CAACyG,QAAD,CAAP,IAAsB1B,CAAC,GAAG0B,QAAJ,KAAiB,CAA3C,EAA+C;AAC3C;AACH;;AAEDJ,UAAAA,eAAe,CAACM,KAAhB,GAAwB1C,MAAM,GAAGH,OAAO,CAACM,EAAX,GAAgBN,OAAO,CAACM,EAAR,GAAaoC,WAAW,CAACpF,IAAvE;AACAiF,UAAAA,eAAe,CAACO,KAAhB,GAAwB3C,MAAM,GAAGH,OAAO,CAACS,EAAR,GAAaiC,WAAW,CAACpF,IAA5B,GAAmC0C,OAAO,CAACS,EAAzE;AACA8B,UAAAA,eAAe,CAACf,QAAhB,GAA2BiB,aAAa,CAACxB,CAAD,CAAxC;AAEAoB,UAAAA,SAAS,CAAC7C,MAAV,CAAiBxE,cAAc,CAACuH,eAAD,EAAkBG,WAAlB,CAA/B;AACH;AACJ;AACJ;;AAEDF,IAAAA,MAAM,CAAC,KAAKO,qBAAL,EAAD,EAA+BtG,OAAO,CAACe,UAAvC,CAAN;AACAgF,IAAAA,MAAM,CAAC,KAAKQ,qBAAL,EAAD,EAA+BvG,OAAO,CAACS,UAAvC,EAAmDoF,SAAS,GAAG7F,OAAO,CAACwG,SAAvE,CAAN;AACH,GAhCD;;AAkCAzG,EAAAA,IAAI,CAACwB,SAAL,CAAe8D,UAAf,GAA4B,SAASA,UAAT,GAAuB;AAC/C,QAAIrF,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIK,IAAI,GAAGL,OAAO,CAACK,IAAnB;AACA,QAAIkD,OAAO,GAAG,KAAKA,OAAL,EAAd;;AAEA,QAAIlD,IAAI,CAACM,KAAL,GAAa,CAAb,IAAkBN,IAAI,CAACF,OAA3B,EAAoC;AAChC,UAAIsG,IAAI,GAAG,IAAI3I,IAAI,CAAC4I,IAAT,CAAc;AACrBC,QAAAA,MAAM,EAAE;AACJhG,UAAAA,KAAK,EAAEN,IAAI,CAACM,KADR;AAEJD,UAAAA,KAAK,EAAEL,IAAI,CAACK,KAFR;AAGJkG,UAAAA,QAAQ,EAAEvG,IAAI,CAACuG;AAHX;AAMR;;;;AAPqB,OAAd,CAAX;AAYAH,MAAAA,IAAI,CAACI,MAAL,CAAYtD,OAAO,CAACK,EAApB,EAAwBL,OAAO,CAACS,EAAhC,EACK8C,MADL,CACYvD,OAAO,CAACM,EADpB,EACwBN,OAAO,CAACQ,EADhC;;AAGA,UAAI/D,OAAO,CAAC+G,WAAZ,EAAyB;AACrB1H,QAAAA,gBAAgB,CAACoH,IAAD,CAAhB;AACH;;AAED,UAAIO,KAAK,GAAG,KAAKC,UAAL,GAAkB,IAAInJ,IAAI,CAAC2H,KAAT,EAA9B;AACAuB,MAAAA,KAAK,CAACjE,MAAN,CAAa0D,IAAb;AAEA,WAAKS,MAAL,CAAYnE,MAAZ,CAAmBiE,KAAnB;AACA,WAAKrB,WAAL,CAAiBqB,KAAjB;AACH;AACJ,GA/BD;;AAiCAjH,EAAAA,IAAI,CAACwB,SAAL,CAAe4F,iBAAf,GAAmC,SAASA,iBAAT,GAA8B;AAC7D,QAAInH,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIoH,QAAQ,GAAG,CAAf;;AAEA,QAAIpH,OAAO,CAACe,UAAR,CAAmBZ,OAAnB,IAA8BH,OAAO,CAACS,UAAR,CAAmBN,OAArD,EAA8D;AAC1DiH,MAAAA,QAAQ,GAAG/E,IAAI,CAACP,GAAL,CAAS9B,OAAO,CAACe,UAAR,CAAmBF,IAA5B,EAAkCb,OAAO,CAACS,UAAR,CAAmBI,IAArD,CAAX;AACH,KAFD,MAEO,IAAIb,OAAO,CAACe,UAAR,CAAmBZ,OAAvB,EAAgC;AACnCiH,MAAAA,QAAQ,GAAGpH,OAAO,CAACe,UAAR,CAAmBF,IAA9B;AACH,KAFM,MAEA,IAAIb,OAAO,CAACS,UAAR,CAAmBN,OAAvB,EAAgC;AACnCiH,MAAAA,QAAQ,GAAGpH,OAAO,CAACS,UAAR,CAAmBI,IAA9B;AACH;;AAED,WAAOuG,QAAP;AACH,GAbD;;AAeArH,EAAAA,IAAI,CAACwB,SAAL,CAAe6D,gBAAf,GAAkC,SAASA,gBAAT,GAA6B;AAC3D,QAAI5B,GAAG,GAAG,IAAV;AACA,QAAIxD,OAAO,GAAGwD,GAAG,CAACxD,OAAlB;AACA,QAAIyD,GAAG,GAAGD,GAAG,CAACC,GAAd;AACA,QAAI4D,UAAU,GAAGrH,OAAO,CAACqH,UAAzB;;AAEA,QAAIA,UAAJ,EAAgB;AACZ,WAAKC,eAAL,GAAuBxJ,IAAI,CAAC4I,IAAL,CAAUa,QAAV,CAAmB9D,GAAG,CAAC+D,MAAJ,EAAnB,EAAiC;AACpDC,QAAAA,IAAI,EAAE;AACF/G,UAAAA,KAAK,EAAE2G;AADL,SAD8C;AAIpDV,QAAAA,MAAM,EAAE;AAJ4C,OAAjC,CAAvB;AAOA,WAAKO,MAAL,CAAYnE,MAAZ,CAAmB,KAAKuE,eAAxB;AACH;AACJ,GAhBD;;AAkBAvH,EAAAA,IAAI,CAACwB,SAAL,CAAe2D,eAAf,GAAiC,SAASA,eAAT,GAA4B;AACzD,QAAIlD,MAAM,GAAG,IAAb;AAEA,QAAIhC,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAI0H,SAAS,GAAG1H,OAAO,CAAC0H,SAAR,IAAqB,EAArC;AACA,QAAIzF,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;AACA,QAAI0F,QAAQ,GAAG,KAAKA,QAApB;;AAEA,QAAID,SAAS,CAACjD,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACH;;AAED,QAAIuC,KAAK,GAAG,KAAKY,cAAL,GAAsB,IAAI9J,IAAI,CAAC2H,KAAT,CAAe;AAC7CtD,MAAAA,MAAM,EAAE,CAAC;AADoC,KAAf,CAAlC;AAIA,QAAI0F,OAAO,GAAGrI,IAAI,CAAC,KAAKsI,IAAL,CAAUC,IAAX,EAAiB,UAAUC,IAAV,EAAgB;AAAE,aAAOA,IAAI,CAAChI,OAAL,CAAaiC,QAAb,KAA0BD,MAAM,CAAChC,OAAP,CAAeiC,QAAhD;AAA2D,KAA9F,CAAJ,CAAoG,CAApG,CAAd;;AAEA,SAAK,IAAIW,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG8E,SAAS,CAACjD,MAAlC,EAA0C7B,GAAG,EAA7C,EAAiD;AAC7C,UAAI8B,IAAI,GAAGgD,SAAS,CAAC9E,GAAD,CAApB;AACA,UAAIqF,KAAK,GAAI,KAAK,CAAlB;AAAA,UAAsBC,KAAK,GAAI,KAAK,CAApC;;AAEA,UAAIjG,QAAJ,EAAc;AACVgG,QAAAA,KAAK,GAAG,CAACJ,OAAO,IAAIF,QAAQ,CAAChE,KAArB,EAA4BJ,OAA5B,EAAR;AACA2E,QAAAA,KAAK,GAAGlG,MAAM,CAACmG,OAAP,CAAezD,IAAI,CAAC0D,IAApB,EAA0B1D,IAAI,CAAC2D,EAA/B,EAAmC,IAAnC,CAAR;AACH,OAHD,MAGO;AACHJ,QAAAA,KAAK,GAAGjG,MAAM,CAACmG,OAAP,CAAezD,IAAI,CAAC0D,IAApB,EAA0B1D,IAAI,CAAC2D,EAA/B,EAAmC,IAAnC,CAAR;AACAH,QAAAA,KAAK,GAAG,CAACL,OAAO,IAAIF,QAAQ,CAAC7D,KAArB,EAA4BP,OAA5B,EAAR;AACH;;AAED,UAAI0E,KAAK,CAACtH,KAAN,OAAkB,CAAlB,IAAuBuH,KAAK,CAACI,MAAN,OAAmB,CAA9C,EAAiD;AAC7C,YAAIC,QAAQ,GAAG,IAAIvK,IAAI,CAACwK,IAAT,CACX,CAAEP,KAAK,CAACrE,EAAR,EAAYsE,KAAK,CAAClE,EAAlB,CADW,EAEX,CAAEiE,KAAK,CAACtH,KAAN,EAAF,EAAiBuH,KAAK,CAACI,MAAN,EAAjB,CAFW,CAAf;AAKA,YAAI7B,IAAI,GAAG3I,IAAI,CAAC4I,IAAL,CAAUa,QAAV,CAAmBgB,QAAnB,EAA6B;AACpCd,UAAAA,IAAI,EAAE;AACF/G,YAAAA,KAAK,EAAEgE,IAAI,CAAChE,KADV;AAEF+H,YAAAA,OAAO,EAAE/D,IAAI,CAAC+D;AAFZ,WAD8B;AAKpC9B,UAAAA,MAAM,EAAE;AAL4B,SAA7B,CAAX;AAQAK,QAAAA,KAAK,CAACjE,MAAN,CAAa0D,IAAb;AACH;AACJ;;AAED,SAAKf,YAAL,CAAkBsB,KAAlB;AACH,GAjDD;;AAmDAjH,EAAAA,IAAI,CAACwB,SAAL,CAAemH,eAAf,GAAiC,SAASA,eAAT,CAA0Bb,OAA1B,EAAmC;AAChE,QAAI7H,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAI2I,cAAc,GAAG3I,OAAO,CAAC2I,cAA7B;AACA,QAAIC,cAAc,GAAG5I,OAAO,CAAC4I,cAA7B;AACA,QAAIpC,SAAS,GAAGxG,OAAO,CAACwG,SAAxB;AACA,QAAIvE,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;AACA,QAAI4G,eAAe,GAAGhB,OAAO,CAAC7H,OAAR,CAAgBK,IAAhB,CAAqBF,OAA3C;AACA,QAAI0F,SAAS,GAAG+C,cAAc,CAACzI,OAAf,GAAyBH,OAAO,CAAC6F,SAAjC,GAA6C,CAA7D;AACA,QAAItC,OAAO,GAAGsE,OAAO,CAACtE,OAAR,EAAd;AACA,QAAIuF,OAAO,GAAGvF,OAAO,CAACtB,QAAQ,GAAG,IAAH,GAAU,IAAnB,CAArB;AACA,QAAI8G,WAAW,GAAG;AACdC,MAAAA,SAAS,EAAEzF,OAAO,CAACtB,QAAQ,GAAG,IAAH,GAAU,IAAnB,CADJ;AAEdgH,MAAAA,OAAO,EAAE1F,OAAO,CAACtB,QAAQ,GAAG,IAAH,GAAU,IAAnB,CAFF;AAGdA,MAAAA,QAAQ,EAAEA;AAHI,KAAlB;AAKA,QAAIlB,UAAU,GAAG,EAAjB;AAEA,QAAImI,SAAS,GAAG,KAAK5D,eAAL,EAAhB;;AAEA,aAASS,MAAT,CAAgBC,aAAhB,EAA+BmD,QAA/B,EAAyCjD,QAAzC,EAAmD;AAC/C,UAAIC,KAAK,GAAGH,aAAa,CAACvB,MAA1B;AACA,UAAIrC,IAAI,GAAGC,IAAI,CAACP,GAAL,CAAS,CAAT,EAAYqH,QAAQ,CAAC/G,IAArB,CAAX;;AAEA,UAAI+G,QAAQ,CAAChJ,OAAb,EAAsB;AAClB,aAAK,IAAIqE,CAAC,GAAG2E,QAAQ,CAACtH,IAAtB,EAA4B2C,CAAC,GAAG2B,KAAhC,EAAuC3B,CAAC,IAAIpC,IAA5C,EAAkD;AAC9C,cAAIgH,GAAG,GAAGvJ,KAAK,CAACmG,aAAa,CAACxB,CAAD,CAAd,CAAf;;AACA,cAAI,CAAC7E,OAAO,CAACyJ,GAAD,EAAMrI,UAAN,CAAZ,EAA+B;AAC3B,gBAAIyD,CAAC,GAAG0B,QAAJ,KAAiB,CAAjB,KAAuB,CAAC2C,eAAD,IAAoBC,OAAO,KAAKM,GAAvD,CAAJ,EAAiE;AAC7DL,cAAAA,WAAW,CAAChE,QAAZ,GAAuBqE,GAAvB;AACAF,cAAAA,SAAS,CAACnG,MAAV,CAAiBvE,kBAAkB,CAACuK,WAAD,EAAcI,QAAd,CAAnC;AAEApI,cAAAA,UAAU,CAACiC,IAAX,CAAgBoG,GAAhB;AACH;AACJ;AACJ;AACJ;AACJ;;AAEDrD,IAAAA,MAAM,CAAC,KAAKO,qBAAL,EAAD,EAA+BsC,cAA/B,CAAN;AACA7C,IAAAA,MAAM,CAAC,KAAKQ,qBAAL,EAAD,EAA+BoC,cAA/B,EAA+C9C,SAAS,GAAGW,SAA3D,CAAN;AAEA,WAAO0C,SAAS,CAACjG,QAAjB;AACH,GA1CD;;AA4CAlD,EAAAA,IAAI,CAACwB,SAAL,CAAe8H,MAAf,GAAwB,SAASA,MAAT,CAAiB5F,GAAjB,EAAsB;AAC1C,QAAID,GAAG,GAAG,IAAV;AACA,QAAIxD,OAAO,GAAGwD,GAAG,CAACxD,OAAlB;AACA,QAAII,MAAM,GAAGoD,GAAG,CAACpD,MAAjB;AACA,QAAIgD,KAAK,GAAGI,GAAG,CAACJ,KAAhB;AACA,QAAInB,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;AACA,QAAIkE,KAAK,GAAG/F,MAAM,CAACqE,MAAnB;AACA,QAAI6E,MAAM,GAAGrH,QAAQ,GAAG9C,KAAH,GAAWC,MAAhC;AACA,QAAImK,SAAS,GAAGnG,KAAK,GAAGA,KAAK,CAACK,GAAN,CAAU6F,MAAV,GAAH,GAAyB,CAA9C;AACA,QAAIE,KAAK,GAAG,KAAKrC,iBAAL,KAA2BnH,OAAO,CAACM,MAAnC,GAA4CiJ,SAAxD;AACA,QAAIE,OAAO,GAAG,CAAC,KAAKC,OAAL,MAAkB,EAAnB,EAAuBjG,GAAvB,IAA8BA,GAA5C;AACA,QAAIkG,OAAO,GAAGF,OAAO,CAACH,MAAD,CAAP,EAAd;AACA,QAAIM,YAAY,GAAG,CAAnB;;AAEA,SAAK,IAAIpF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,KAApB,EAA2B3B,CAAC,EAA5B,EAAgC;AAC5B,UAAIqF,SAAS,GAAGzJ,MAAM,CAACoE,CAAD,CAAN,CAAUf,GAAV,CAAc6F,MAAd,GAAhB;;AACA,UAAIO,SAAS,GAAGL,KAAZ,IAAqBG,OAAzB,EAAkC;AAC9BC,QAAAA,YAAY,GAAGvH,IAAI,CAACP,GAAL,CAAS8H,YAAT,EAAuBC,SAAvB,CAAf;AACH;AACJ;;AAED,QAAI5H,QAAJ,EAAc;AACV,WAAKwB,GAAL,GAAW,IAAIpF,GAAJ,CACPoF,GAAG,CAACG,EADG,EACCH,GAAG,CAACO,EADL,EAEPP,GAAG,CAACG,EAAJ,GAASgG,YAAT,GAAwBJ,KAFjB,EAEwB/F,GAAG,CAACM,EAF5B,CAAX;AAIH,KALD,MAKO;AACH,WAAKN,GAAL,GAAW,IAAIpF,GAAJ,CACPoF,GAAG,CAACG,EADG,EACCH,GAAG,CAACO,EADL,EAEPP,GAAG,CAACI,EAFG,EAECJ,GAAG,CAACO,EAAJ,GAAS4F,YAAT,GAAwBJ,KAFzB,CAAX;AAIH;;AAED,SAAKM,YAAL;AACA,SAAKC,aAAL;AACA,SAAKC,YAAL;AACH,GApCD;;AAsCAjK,EAAAA,IAAI,CAACwB,SAAL,CAAe0I,sBAAf,GAAwC,SAASA,sBAAT,GAAmC;AACvE,WAAO,KAAK3D,qBAAL,EAAP;AACH,GAFD;;AAIAvG,EAAAA,IAAI,CAACwB,SAAL,CAAe2I,cAAf,GAAgC,SAASA,cAAT,CAAyBrH,KAAzB,EAAgC;AAC5D,WAAOA,KAAK,CAACsH,KAAb;AACH,GAFD;;AAIApK,EAAAA,IAAI,CAACwB,SAAL,CAAewI,aAAf,GAA+B,SAASA,aAAT,GAA0B;AACrD,QAAI/H,MAAM,GAAG,IAAb;AAEA,QAAIwB,GAAG,GAAG,IAAV;AACA,QAAIxD,OAAO,GAAGwD,GAAG,CAACxD,OAAlB;AACA,QAAII,MAAM,GAAGoD,GAAG,CAACpD,MAAjB;AACA,QAAIgK,kBAAkB,GAAG,KAAKA,kBAAL,EAAzB;AACA,QAAInI,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;AACA,QAAIsB,OAAO,GAAG,KAAKA,OAAL,EAAd;AACA,QAAIG,MAAM,GAAG1D,OAAO,CAACI,MAAR,CAAesD,MAA5B;AACA,QAAIsC,aAAa,GAAG,KAAKiE,sBAAL,EAApB;AACA,QAAII,WAAW,GAAG,KAAKlD,iBAAL,KAA2BnH,OAAO,CAACM,MAArD;;AAEA,SAAK,IAAIsC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGxC,MAAM,CAACqE,MAA/B,EAAuC7B,GAAG,EAA1C,EAA8C;AAC1C,UAAIC,KAAK,GAAGzC,MAAM,CAACwC,GAAD,CAAlB;AACA,UAAI0H,MAAM,GAAGtI,MAAM,CAACkI,cAAP,CAAsBrH,KAAtB,CAAb;AACA,UAAIgH,SAAS,GAAG5H,QAAQ,GAAGY,KAAK,CAACY,GAAN,CAAU6E,MAAV,EAAH,GAAwBzF,KAAK,CAACY,GAAN,CAAU9C,KAAV,EAAhD;AACA,UAAI4J,QAAQ,GAAGvE,aAAa,CAACsE,MAAD,CAAb,GAAyBT,SAAS,GAAG,CAApD;AACA,UAAIW,QAAQ,GAAI,KAAK,CAArB;AAAA,UAAyBC,iBAAiB,GAAI,KAAK,CAAnD;AAAA,UAAuDC,gBAAgB,GAAI,KAAK,CAAhF;;AAEA,UAAIzI,QAAJ,EAAc;AACV,YAAImI,kBAAJ,EAAwB;AACpBK,UAAAA,iBAAiB,GAAGzE,aAAa,CAACsE,MAAD,CAAjC;AACAI,UAAAA,gBAAgB,GAAG1E,aAAa,CAACsE,MAAM,GAAG,CAAV,CAAhC;AAEA,cAAIK,MAAM,GAAGF,iBAAiB,GAAG,CAACC,gBAAgB,GAAGD,iBAApB,IAAyC,CAA1E;AACAF,UAAAA,QAAQ,GAAGI,MAAM,GAAId,SAAS,GAAG,CAAjC;AACH;;AAED,YAAIe,MAAM,GAAGrH,OAAO,CAACM,EAArB;;AAEA,YAAIH,MAAJ,EAAY;AACRkH,UAAAA,MAAM,IAAIP,WAAV;AACAxH,UAAAA,KAAK,CAAC7C,OAAN,CAAc6K,cAAd,GAA+B/L,IAA/B;AACH,SAHD,MAGO;AACH8L,UAAAA,MAAM,IAAIP,WAAW,GAAGxH,KAAK,CAACY,GAAN,CAAU9C,KAAV,EAAxB;AACAkC,UAAAA,KAAK,CAAC7C,OAAN,CAAc6K,cAAd,GAA+B9L,KAA/B;AACH;;AAEDyL,QAAAA,QAAQ,GAAG3H,KAAK,CAACY,GAAN,CAAUqH,IAAV,CAAeF,MAAf,EAAuBL,QAAvB,CAAX;AACH,OApBD,MAoBO;AACH,YAAIH,kBAAJ,EAAwB;AACpBK,UAAAA,iBAAiB,GAAGzE,aAAa,CAACsE,MAAD,CAAjC;AACAI,UAAAA,gBAAgB,GAAG1E,aAAa,CAACsE,MAAM,GAAG,CAAV,CAAhC;AACH,SAHD,MAGO;AACHG,UAAAA,iBAAiB,GAAGF,QAApB;AACAG,UAAAA,gBAAgB,GAAGH,QAAQ,GAAGV,SAA9B;AACH;;AAED,YAAIkB,MAAM,GAAGxH,OAAO,CAACS,EAArB;;AAEA,YAAIN,MAAJ,EAAY;AACRqH,UAAAA,MAAM,IAAIV,WAAW,GAAGxH,KAAK,CAACY,GAAN,CAAU6E,MAAV,EAAxB;AACAzF,UAAAA,KAAK,CAAC7C,OAAN,CAAc6K,cAAd,GAA+BhM,MAA/B;AACH,SAHD,MAGO;AACHkM,UAAAA,MAAM,IAAIV,WAAV;AACAxH,UAAAA,KAAK,CAAC7C,OAAN,CAAc6K,cAAd,GAA+BjM,GAA/B;AACH;;AAED4L,QAAAA,QAAQ,GAAG,IAAInM,GAAJ,CAAQoM,iBAAR,EAA2BM,MAA3B,EACKL,gBADL,EACuBK,MAAM,GAAGlI,KAAK,CAACY,GAAN,CAAU6E,MAAV,EADhC,CAAX;AAEH;;AAEDzF,MAAAA,KAAK,CAACwG,MAAN,CAAamB,QAAb;AACH;AACJ,GAjED;;AAmEAzK,EAAAA,IAAI,CAACwB,SAAL,CAAeoB,gBAAf,GAAkC,SAASA,gBAAT,GAA6B;AAC3D,QAAI,KAAK3C,OAAL,CAAa2C,gBAAb,IAAiC,CAAC,KAAK3C,OAAL,CAAaiC,QAAnD,EAA6D;AACzD,UAAI+D,aAAa,GAAG,KAAKM,qBAAL,EAApB;AACA,UAAIlG,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAIsC,KAAJ;;AAEA,WAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGxC,MAAM,CAACqE,MAA/B,EAAuC7B,GAAG,EAA1C,EAA8C;AAC1C,YAAIjC,KAAK,GAAG0B,IAAI,CAAC2I,GAAL,CAAShF,aAAa,CAACpD,GAAG,GAAG,CAAP,CAAb,GAAyBoD,aAAa,CAACpD,GAAD,CAA/C,CAAZ;AACA,YAAI4H,QAAQ,GAAGpK,MAAM,CAACwC,GAAD,CAAN,CAAYa,GAA3B;;AAEA,YAAI+G,QAAQ,CAAC7J,KAAT,KAAmBA,KAAvB,EAA8B;AAC1B,cAAI6J,QAAQ,CAAClC,MAAT,KAAoB3H,KAAxB,EAA+B;AAC3B+B,YAAAA,KAAK,GAAG,CAAC,EAAT;AACA;AACH;;AACDA,UAAAA,KAAK,GAAG,CAAC,EAAT;AACH;AACJ;;AAED,UAAIA,KAAJ,EAAW;AACP,aAAK,IAAIuI,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG7K,MAAM,CAACqE,MAAnC,EAA2CwG,KAAK,EAAhD,EAAoD;AAChD7K,UAAAA,MAAM,CAAC6K,KAAD,CAAN,CAAcjL,OAAd,CAAsBwC,QAAtB,GAAiCE,KAAjC;AACAtC,UAAAA,MAAM,CAAC6K,KAAD,CAAN,CAAc5B,MAAd,CAAqB,IAAIhL,GAAJ,EAArB;AACH;;AACD,eAAO,IAAP;AACH;AACJ;AACJ,GA3BD;;AA6BA0B,EAAAA,IAAI,CAACwB,SAAL,CAAeuI,YAAf,GAA8B,SAASA,YAAT,GAAyB;AACnD,QAAItG,GAAG,GAAG,IAAV;AACA,QAAIxD,OAAO,GAAGwD,GAAG,CAACxD,OAAlB;AACA,QAAIoD,KAAK,GAAGI,GAAG,CAACJ,KAAhB;AACA,QAAIM,MAAM,GAAG1D,OAAO,CAACI,MAAR,CAAesD,MAA5B;AACA,QAAIzB,QAAQ,GAAGjC,OAAO,CAACiC,QAAvB;;AAEA,QAAImB,KAAJ,EAAW;AACP,UAAInB,QAAJ,EAAc;AACVmB,QAAAA,KAAK,CAACpD,OAAN,CAAcc,KAAd,GAAsB4C,MAAM,GAAG3E,KAAH,GAAWD,IAAvC;AACAsE,QAAAA,KAAK,CAACpD,OAAN,CAAckL,MAAd,GAAuB9H,KAAK,CAACpD,OAAN,CAAc+E,QAArC;AACH,OAHD,MAGO;AACH3B,QAAAA,KAAK,CAACpD,OAAN,CAAcc,KAAd,GAAsBsC,KAAK,CAACpD,OAAN,CAAc+E,QAApC;AACA3B,QAAAA,KAAK,CAACpD,OAAN,CAAckL,MAAd,GAAuBxH,MAAM,GAAG9E,GAAH,GAASC,MAAtC;AACH;;AAEDuE,MAAAA,KAAK,CAACiG,MAAN,CAAa,KAAK5F,GAAlB;AACH;AACJ,GAlBD;;AAoBA1D,EAAAA,IAAI,CAACwB,SAAL,CAAeyI,YAAf,GAA8B,SAASA,YAAT,GAAyB;AACnD,QAAIhI,MAAM,GAAG,IAAb;;AAEA,SAAK,IAAIY,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAKyB,KAAL,CAAWI,MAAnC,EAA2C7B,GAAG,EAA9C,EAAkD;AAC9C,UAAI8B,IAAI,GAAG1C,MAAM,CAACqC,KAAP,CAAazB,GAAb,CAAX;AACA,UAAI+B,KAAK,GAAGD,IAAI,CAAC1E,OAAL,CAAa2E,KAAzB;AACA,UAAIwG,IAAI,GAAI,KAAK,CAAjB;;AAEA,UAAI1L,OAAO,CAACkF,KAAD,CAAX,EAAoB;AAChB,YAAI3C,MAAM,CAACoJ,gBAAP,CAAwBzG,KAAxB,CAAJ,EAAoC;AAChCD,UAAAA,IAAI,CAAC2G,IAAL;AACH,SAFD,MAEO;AACH3G,UAAAA,IAAI,CAAC4G,IAAL;AACH;;AAEDH,QAAAA,IAAI,GAAGnJ,MAAM,CAACuJ,QAAP,CAAgB5G,KAAhB,CAAP;AACH,OARD,MAQO;AACHD,QAAAA,IAAI,CAAC4G,IAAL;AACH;;AAED5G,MAAAA,IAAI,CAAC2E,MAAL,CAAY8B,IAAI,IAAInJ,MAAM,CAACuB,OAAP,EAApB;AACH;AACJ,GAtBD;;AAwBAxD,EAAAA,IAAI,CAACwB,SAAL,CAAegK,QAAf,GAA0B,SAASA,QAAT,CAAmB5G,KAAnB,EAA0B;AAChD,WAAO,KAAKwD,OAAL,CAAaxD,KAAb,CAAP;AACH,GAFD;;AAIA5E,EAAAA,IAAI,CAACwB,SAAL,CAAeiK,OAAf,GAAyB,SAASA,OAAT,CAAkBC,UAAlB,EAA8B;AACnD,QAAIlI,OAAO,GAAGkI,UAAU,CAAClI,OAAX,EAAd;AACA,QAAItB,QAAQ,GAAG,KAAKjC,OAAL,CAAaiC,QAA5B;AACA,QAAImH,GAAG,GAAGnH,QAAQ,GAAG/C,CAAH,GAAOD,CAAzB;AAEA,SAAKwE,GAAL,CAASiI,MAAT,CAAgBnI,OAAhB,EAAyB6F,GAAzB;;AACA,QAAInH,QAAJ,EAAc;AACV,WAAKwB,GAAL,CAASkI,MAAT,CAAgB,CAAhB,EAAmB,KAAKpI,OAAL,GAAe+E,MAAf,KAA0B/E,OAAO,CAAC+E,MAAR,EAA7C;AACH,KAFD,MAEO;AACH,WAAK7E,GAAL,CAASkI,MAAT,CAAgB,KAAKpI,OAAL,GAAe5C,KAAf,KAAyB4C,OAAO,CAAC5C,KAAR,EAAzC,EAA0D,CAA1D;AACH;;AACD,SAAK8C,GAAL,CAAS2F,GAAG,GAAG,CAAf,KAAqB,KAAK7F,OAAL,GAAe6F,GAAG,GAAG,CAArB,IAA0B7F,OAAO,CAAC6F,GAAG,GAAG,CAAP,CAAtD;AACA,SAAK3F,GAAL,CAAS2F,GAAG,GAAG,CAAf,KAAqB,KAAK7F,OAAL,GAAe6F,GAAG,GAAG,CAArB,IAA0B7F,OAAO,CAAC6F,GAAG,GAAG,CAAP,CAAtD;AACH,GAbD;;AAeArJ,EAAAA,IAAI,CAACwB,SAAL,CAAeqK,aAAf,GAA+B,SAASA,aAAT,CAAwBjH,KAAxB,EAA+BG,QAA/B,EAAyC9E,OAAzC,EAAkD;AAC7E,QAAI6L,IAAI,GAAGtM,WAAW,CAACS,OAAD,CAAtB;AACA,QAAImE,IAAI,GAAGQ,KAAX;;AAEA,QAAIkH,IAAJ,EAAU;AACN1H,MAAAA,IAAI,GAAG0H,IAAI,CAAC;AAAElH,QAAAA,KAAK,EAAEA,KAAT;AAAgBG,QAAAA,QAAQ,EAAEA,QAA1B;AAAoCgH,QAAAA,MAAM,EAAE9L,OAAO,CAAC8L,MAApD;AAA4DC,QAAAA,OAAO,EAAE/L,OAAO,CAAC+L;AAA7E,OAAD,CAAX;AACH,KAFD,MAEO,IAAI/L,OAAO,CAAC8L,MAAZ,EAAoB;AACvB3H,MAAAA,IAAI,GAAG,KAAKlE,YAAL,CAAkB6L,MAAlB,CAAyBE,UAAzB,CAAoChM,OAAO,CAAC8L,MAA5C,EAAoD,CAAEnH,KAAF,CAApD,EAA+D3E,OAAO,CAAC+L,OAAvE,CAAP;AACH;;AAED,WAAO5H,IAAP;AACH,GAXD;;AAaApE,EAAAA,IAAI,CAACwB,SAAL,CAAe4J,IAAf,GAAsB,SAASA,IAAT,CAAe/C,IAAf,EAAsBC,EAAtB,EAA0B4D,KAA1B,EAAiC;AACnD,QAAId,IAAI,GAAG,KAAKhD,OAAL,CAAaC,IAAb,EAAmBC,EAAnB,EAAuB4D,KAAvB,CAAX;;AACA,QAAId,IAAJ,EAAU;AACN,aAAOA,IAAI,CAAC3D,MAAL,EAAP;AACH;AACJ,GALD;;AAOAzH,EAAAA,IAAI,CAACwB,SAAL,CAAe2K,UAAf,GAA4B,SAASA,UAAT,GAAuB;AAC/C,QAAIzI,GAAG,GAAG,KAAKA,GAAL,CAAS0I,KAAT,EAAV;AACA,QAAI/L,MAAM,GAAG,KAAKA,MAAlB;;AACA,QAAIA,MAAM,CAACqE,MAAX,EAAmB;AACf,UAAIuD,IAAI,GAAG,KAAKhI,OAAL,CAAaiC,QAAb,GAAwB/C,CAAxB,GAA4BD,CAAvC;;AACA,UAAI,KAAKgB,YAAL,CAAkBmM,UAAlB,CAA6BpE,IAA7B,CAAJ,EAAwC;AACpC,YAAIqE,MAAM,GAAG,KAAKC,cAAL,EAAb;AACA7I,QAAAA,GAAG,CAACuE,IAAI,GAAG,CAAR,CAAH,IAAiBqE,MAAM,CAACE,KAAxB;AACA9I,QAAAA,GAAG,CAACuE,IAAI,GAAG,CAAR,CAAH,IAAiBqE,MAAM,CAACG,GAAxB;AACH,OAJD,MAIO;AACH,YAAIpM,MAAM,CAAC,CAAD,CAAN,CAAUJ,OAAV,CAAkBG,OAAtB,EAA+B;AAC3BsD,UAAAA,GAAG,CAACgJ,IAAJ,CAASrM,MAAM,CAAC,CAAD,CAAN,CAAUqD,GAAnB;AACH;;AACD,YAAIiJ,SAAS,GAAGtM,MAAM,CAACA,MAAM,CAACqE,MAAP,GAAgB,CAAjB,CAAtB;;AACA,YAAIiI,SAAS,CAAC1M,OAAV,CAAkBG,OAAtB,EAA+B;AAC3BsD,UAAAA,GAAG,CAACgJ,IAAJ,CAASC,SAAS,CAACjJ,GAAnB;AACH;AACJ;AACJ;;AAED,WAAOA,GAAP;AACH,GArBD;;AAuBA1D,EAAAA,IAAI,CAACwB,SAAL,CAAe+K,cAAf,GAAgC,SAASA,cAAT,GAA2B;AACvD,QAAItK,MAAM,GAAG,IAAb;AAEA,QAAIwB,GAAG,GAAG,KAAKxD,OAAf;AACA,QAAIiC,QAAQ,GAAGuB,GAAG,CAACvB,QAAnB;AACA,QAAI+C,OAAO,GAAGxB,GAAG,CAACwB,OAAlB;AACA,QAAIoF,kBAAkB,GAAG,KAAKA,kBAAL,EAAzB;AACA,QAAIpE,aAAa,GAAG,KAAKiE,sBAAL,EAApB;AACA,QAAI0C,WAAW,GAAG1K,QAAQ,GAAG/C,CAAH,GAAOD,CAAjC;AACA,QAAImB,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIwM,aAAa,GAAG5H,OAAO,GAAG,CAAH,GAAO,CAAlC;AACA,QAAI6H,WAAW,GAAG7H,OAAO,GAAG,CAAH,GAAO,CAAhC;AACA,QAAI8H,cAAc,GAAG,CAArB;AACA,QAAIC,YAAY,GAAG,CAAnB;;AAEA,SAAK,IAAInK,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGxC,MAAM,CAACqE,MAA/B,EAAuC7B,GAAG,EAA1C,EAA8C;AAC1C,UAAIC,KAAK,GAAGzC,MAAM,CAACwC,GAAD,CAAlB;AACA,UAAI0H,MAAM,GAAGtI,MAAM,CAACkI,cAAP,CAAsBrH,KAAtB,CAAb;AACA,UAAImK,SAAS,GAAI,KAAK,CAAtB;AAAA,UAA0BC,OAAO,GAAI,KAAK,CAA1C;;AAEA,UAAI7C,kBAAJ,EAAwB;AACpB4C,QAAAA,SAAS,GAAGhH,aAAa,CAACsE,MAAM,GAAGsC,aAAV,CAAzB;AACAK,QAAAA,OAAO,GAAGjH,aAAa,CAACsE,MAAM,GAAGuC,WAAV,CAAvB;AACH,OAHD,MAGO;AACHG,QAAAA,SAAS,GAAGC,OAAO,GAAGjH,aAAa,CAACsE,MAAD,CAAnC;AACH;;AAEDwC,MAAAA,cAAc,GAAGzK,IAAI,CAACP,GAAL,CAASgL,cAAT,EAAyBE,SAAS,GAAGnK,KAAK,CAACY,GAAN,CAAUkJ,WAAW,GAAG,CAAxB,CAArC,CAAjB;AACAI,MAAAA,YAAY,GAAG1K,IAAI,CAACP,GAAL,CAASiL,YAAT,EAAuBlK,KAAK,CAACY,GAAN,CAAUkJ,WAAW,GAAG,CAAxB,IAA6BM,OAApD,CAAf;AACH;;AAED,WAAO;AACHV,MAAAA,KAAK,EAAEO,cADJ;AAEHN,MAAAA,GAAG,EAAEO;AAFF,KAAP;AAIH,GAnCD;;AAqCAhN,EAAAA,IAAI,CAACwB,SAAL,CAAe2L,UAAf,GAA4B,SAASA,UAAT,CAAqB9E,IAArB,EAA2BC,EAA3B,EAA+BzG,GAA/B,EAAoCE,GAApC,EAAyCuK,MAAzC,EAAiD;AACzE,QAAIrM,OAAO,GAAG,KAAKA,OAAnB;;AAEA,QAAKoI,IAAI,GAAGxG,GAAP,IAAcyK,MAAM,GAAG,CAAvB,KAA6B,CAAC5M,OAAO,CAACO,OAAO,CAAC4B,GAAT,CAAR,IAAyB5B,OAAO,CAAC4B,GAAR,IAAeA,GAArE,CAAD,IAAgFE,GAAG,GAAGuG,EAAN,IAAYgE,MAAM,GAAG,CAArB,KAA2B,CAAC5M,OAAO,CAACO,OAAO,CAAC8B,GAAT,CAAR,IAAyBA,GAAG,IAAI9B,OAAO,CAAC8B,GAAnE,CAApF,EAA8J;AAC1J,aAAO,IAAP;AACH;;AAED,QAAKuG,EAAE,GAAGzG,GAAL,IAAYyK,MAAM,GAAG,CAAtB,IAA6BvK,GAAG,GAAGsG,IAAN,IAAciE,MAAM,GAAG,CAAxD,EAA4D;AACxD,aAAO;AACHzK,QAAAA,GAAG,EAAEwG,IADF;AAEHtG,QAAAA,GAAG,EAAEuG;AAFF,OAAP;AAIH;;AAED,QAAI8E,SAAS,GAAG9E,EAAE,GAAGD,IAArB;AACA,QAAIgF,QAAQ,GAAGhF,IAAf;AACA,QAAIiF,QAAQ,GAAGhF,EAAf;;AAEA,QAAID,IAAI,GAAGxG,GAAP,IAAcyK,MAAM,GAAG,CAA3B,EAA8B;AAC1Be,MAAAA,QAAQ,GAAGxN,UAAU,CAACwI,IAAD,EAAOxG,GAAP,EAAYE,GAAZ,CAArB;AACAuL,MAAAA,QAAQ,GAAGzN,UAAU,CAACwI,IAAI,GAAG+E,SAAR,EAAmBvL,GAAG,GAAGuL,SAAzB,EAAoCrL,GAApC,CAArB;AACH,KAHD,MAGO,IAAIuG,EAAE,GAAGvG,GAAL,IAAYuK,MAAM,GAAG,CAAzB,EAA4B;AAC/BgB,MAAAA,QAAQ,GAAGzN,UAAU,CAACyI,EAAD,EAAKzG,GAAL,EAAUE,GAAV,CAArB;AACAsL,MAAAA,QAAQ,GAAGxN,UAAU,CAACyI,EAAE,GAAG8E,SAAN,EAAiBvL,GAAjB,EAAsBE,GAAG,GAAGqL,SAA5B,CAArB;AACH;;AAED,WAAO;AACHvL,MAAAA,GAAG,EAAEwL,QADF;AAEHtL,MAAAA,GAAG,EAAEuL;AAFF,KAAP;AAIH,GA9BD;;AAgCAtN,EAAAA,IAAI,CAACwB,SAAL,CAAe+L,UAAf,GAA4B,SAASA,UAAT,GAAuB;AAC/C,WAAO;AACH1L,MAAAA,GAAG,EAAE,KAAK2L,SADP;AAEHzL,MAAAA,GAAG,EAAE,KAAK0L;AAFP,KAAP;AAIH,GALD;;AAOAzN,EAAAA,IAAI,CAACwB,SAAL,CAAe6I,kBAAf,GAAoC,SAASA,kBAAT,GAA+B;AAC/D,WAAO,CAAC,KAAKpK,OAAL,CAAayN,SAArB;AACH,GAFD,CAruBgC,CAyuBhC;;;AACA1N,EAAAA,IAAI,CAACwB,SAAL,CAAemM,kBAAf,GAAoC,SAASA,kBAAT,GAA+B,CAClE,CADD;;AAGA,SAAO3N,IAAP;AACH,CA9uBW,CA8uBV9B,YA9uBU,CAAZ;;AAgvBA6B,iBAAiB,CAACC,IAAD,EAAO;AACpBK,EAAAA,MAAM,EAAE;AACJD,IAAAA,OAAO,EAAE,IADL;AAEJqC,IAAAA,QAAQ,EAAE,CAFN;AAGJkB,IAAAA,MAAM,EAAE,KAHJ;AAIJtB,IAAAA,IAAI,EAAE,CAJF;AAKJP,IAAAA,IAAI,EAAE;AALF,GADY;AAQpBxB,EAAAA,IAAI,EAAE;AACFM,IAAAA,KAAK,EAAE,CADL;AAEFD,IAAAA,KAAK,EAAEhC,KAFL;AAGFyB,IAAAA,OAAO,EAAE;AAHP,GARc;AAapBiD,EAAAA,KAAK,EAAE;AACHjD,IAAAA,OAAO,EAAE,IADN;AAEH4E,IAAAA,QAAQ,EAAEpG;AAFP,GAba;AAiBpBoC,EAAAA,UAAU,EAAE;AACRD,IAAAA,KAAK,EAAE9B,OADC;AAER6B,IAAAA,IAAI,EAAE,CAFE;AAGRgB,IAAAA,IAAI,EAAE,CAHE;AAIRO,IAAAA,IAAI,EAAE;AAJE,GAjBQ;AAuBpB3B,EAAAA,UAAU,EAAE;AACRK,IAAAA,KAAK,EAAE9B,OADC;AAER6B,IAAAA,IAAI,EAAE,CAFE;AAGRgB,IAAAA,IAAI,EAAE,CAHE;AAIRO,IAAAA,IAAI,EAAE;AAJE,GAvBQ;AA6BpBuL,EAAAA,iBAAiB,EAAE,CA7BC;AA8BpB3M,EAAAA,aAAa,EAAEhC,OA9BK;AA+BpB4B,EAAAA,aAAa,EAAEnC,IA/BK;AAgCpBmK,EAAAA,cAAc,EAAE;AACZ/G,IAAAA,IAAI,EAAE,CADM;AAEZO,IAAAA,IAAI,EAAE;AAFM,GAhCI;AAoCpBuG,EAAAA,cAAc,EAAE;AACZxI,IAAAA,OAAO,EAAE,KADG;AAEZQ,IAAAA,KAAK,EAAE,CAFK;AAGZD,IAAAA,KAAK,EAAEhC,KAHK;AAIZmD,IAAAA,IAAI,EAAE,CAJM;AAKZO,IAAAA,IAAI,EAAE;AALM,GApCI;AA2CpB;AACA9B,EAAAA,MAAM,EAAE,CA5CY;AA6CpBH,EAAAA,OAAO,EAAE,IA7CW;AA8CpB6E,EAAAA,OAAO,EAAE,KA9CW;AA+CpByI,EAAAA,SAAS,EAAE,IA/CS;AAgDpBpJ,EAAAA,KAAK,EAAE;AACHxB,IAAAA,KAAK,EAAE;AACHsB,MAAAA,IAAI,EAAE;AADH;AADJ,GAhDa;AAsDpB4C,EAAAA,WAAW,EAAE,IAtDO;AAuDpB7F,EAAAA,YAAY,EAAE;AAvDM,CAAP,CAAjB;AA0DA,eAAenB,IAAf","sourcesContent":["import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\n\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\n\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = (function (ChartElement) {\n    function Axis(options, chartService) {\n        if ( chartService === void 0 ) chartService = new ChartService();\n\n        ChartElement.call(this, options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    }\n\n    if ( ChartElement ) Axis.__proto__ = ChartElement;\n    Axis.prototype = Object.create( ChartElement && ChartElement.prototype );\n    Axis.prototype.constructor = Axis;\n\n    Axis.prototype.initFields = function initFields () {\n    };\n\n    // abstract labelsCount(): Number\n    // abstract createAxisLabel(index, options): AxisLabel\n\n    Axis.prototype.labelsRange = function labelsRange () {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    };\n\n    Axis.prototype.createLabels = function createLabels () {\n        var this$1 = this;\n\n        var options = this.options;\n        var align = options.vertical ? RIGHT : CENTER;\n        var labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        var step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            var range = this.labelsRange();\n            var rotation = labelOptions.rotation;\n\n            if (isObject(rotation)) {\n                labelOptions.alignRotation = rotation.align;\n                labelOptions.rotation = rotation.angle;\n            }\n\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            for (var idx = range.min; idx < range.max; idx += step) {\n                var label = this$1.createAxisLabel(idx, labelOptions);\n                if (label) {\n                    this$1.append(label);\n                    this$1.labels.push(label);\n                }\n            }\n        }\n    };\n\n    Axis.prototype.clearLabels = function clearLabels () {\n        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n        this.labels = [];\n    };\n\n    Axis.prototype.clearTitle = function clearTitle () {\n        var this$1 = this;\n\n        if (this.title) {\n            this.children = grep(this.children, function (child) { return child !== this$1.title; });\n            this.title = undefined;\n        }\n    };\n\n    Axis.prototype.clear = function clear () {\n        this.clearLabels();\n        this.clearTitle();\n    };\n\n    Axis.prototype.lineBox = function lineBox () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var axisX = mirror ? box.x1 : box.x2;\n        var axisY = mirror ? box.y2 : box.y1;\n        var lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    };\n\n    Axis.prototype.createTitle = function createTitle () {\n        var options = this.options;\n        var titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            var title = new TextBox(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    };\n\n    Axis.prototype.createNotes = function createNotes () {\n        var this$1 = this;\n\n        var options = this.options;\n        var notes = options.notes;\n        var items = notes.data || [];\n\n        this.notes = [];\n\n        for (var i = 0; i < items.length; i++) {\n            var item = deepExtend({}, notes, items[i]);\n            item.value = this$1.parseNoteValue(item.value);\n\n            var note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this$1.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this$1.append(note);\n                this$1.notes.push(note);\n            }\n        }\n    };\n\n    Axis.prototype.parseNoteValue = function parseNoteValue (value) {\n        return value;\n    };\n\n    Axis.prototype.renderVisual = function renderVisual () {\n        ChartElement.prototype.renderVisual.call(this);\n\n        this.createPlotBands();\n    };\n\n    Axis.prototype.createVisual = function createVisual () {\n        ChartElement.prototype.createVisual.call(this);\n\n        this.createBackground();\n        this.createLine();\n    };\n\n    Axis.prototype.gridLinesVisual = function gridLinesVisual () {\n        var gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new draw.Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    };\n\n    Axis.prototype.createTicks = function createTicks (lineGroup) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var mirror = options.labels.mirror;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (var i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    };\n\n    Axis.prototype.createLine = function createLine () {\n        var options = this.options;\n        var line = options.line;\n        var lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            var path = new draw.Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            var group = this._lineGroup = new draw.Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    };\n\n    Axis.prototype.getActualTickSize = function getActualTickSize () {\n        var options = this.options;\n        var tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    };\n\n    Axis.prototype.createBackground = function createBackground () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var background = options.background;\n\n        if (background) {\n            this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    };\n\n    Axis.prototype.createPlotBands = function createPlotBands () {\n        var this$1 = this;\n\n        var options = this.options;\n        var plotBands = options.plotBands || [];\n        var vertical = options.vertical;\n        var plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        var group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1.options.vertical; })[0];\n\n        for (var idx = 0; idx < plotBands.length; idx++) {\n            var item = plotBands[idx];\n            var slotX = (void 0), slotY = (void 0);\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this$1.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this$1.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                var bandRect = new geom.Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                var path = draw.Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n            }\n        }\n\n        this.appendVisual(group);\n    };\n\n    Axis.prototype.createGridLines = function createGridLines (altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var minorUnit = options.minorUnit;\n        var vertical = options.vertical;\n        var axisLineVisible = altAxis.options.line.visible;\n        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        var lineBox = altAxis.lineBox();\n        var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (var i = gridLine.skip; i < count; i += step) {\n                    var pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    };\n\n    Axis.prototype.reflow = function reflow (box) {\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var title = ref.title;\n        var vertical = options.vertical;\n        var count = labels.length;\n        var sizeFn = vertical ? WIDTH : HEIGHT;\n        var titleSize = title ? title.box[sizeFn]() : 0;\n        var space = this.getActualTickSize() + options.margin + titleSize;\n        var rootBox = (this.getRoot() || {}).box || box;\n        var boxSize = rootBox[sizeFn]();\n        var maxLabelSize = 0;\n\n        for (var i = 0; i < count; i++) {\n            var labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    };\n\n    Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions () {\n        return this.getMajorTickPositions();\n    };\n\n    Axis.prototype.labelTickIndex = function labelTickIndex (label) {\n        return label.index;\n    };\n\n    Axis.prototype.arrangeLabels = function arrangeLabels () {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var vertical = options.vertical;\n        var lineBox = this.lineBox();\n        var mirror = options.labels.mirror;\n        var tickPositions = this.getLabelsTickPositions();\n        var labelOffset = this.getActualTickSize() + options.margin;\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var labelSize = vertical ? label.box.height() : label.box.width();\n            var labelPos = tickPositions[tickIx] - (labelSize / 2);\n            var labelBox = (void 0), firstTickPosition = (void 0), nextTickPosition = (void 0);\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    firstTickPosition = tickPositions[tickIx];\n                    nextTickPosition = tickPositions[tickIx + 1];\n\n                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    labelPos = middle - (labelSize / 2);\n                }\n\n                var labelX = lineBox.x2;\n\n                if (mirror) {\n                    labelX += labelOffset;\n                    label.options.rotationOrigin = LEFT;\n                } else {\n                    labelX -= labelOffset + label.box.width();\n                    label.options.rotationOrigin = RIGHT;\n                }\n\n                labelBox = label.box.move(labelX, labelPos);\n            } else {\n                if (labelsBetweenTicks) {\n                    firstTickPosition = tickPositions[tickIx];\n                    nextTickPosition = tickPositions[tickIx + 1];\n                } else {\n                    firstTickPosition = labelPos;\n                    nextTickPosition = labelPos + labelSize;\n                }\n\n                var labelY = lineBox.y1;\n\n                if (mirror) {\n                    labelY -= labelOffset + label.box.height();\n                    label.options.rotationOrigin = BOTTOM;\n                } else {\n                    labelY += labelOffset;\n                    label.options.rotationOrigin = TOP;\n                }\n\n                labelBox = new Box(firstTickPosition, labelY,\n                                nextTickPosition, labelY + label.box.height());\n            }\n\n            label.reflow(labelBox);\n        }\n    };\n\n    Axis.prototype.autoRotateLabels = function autoRotateLabels () {\n        if (this.options.autoRotateLabels && !this.options.vertical) {\n            var tickPositions = this.getMajorTickPositions();\n            var labels = this.labels;\n            var angle;\n\n            for (var idx = 0; idx < labels.length; idx++) {\n                var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n                var labelBox = labels[idx].box;\n\n                if (labelBox.width() > width) {\n                    if (labelBox.height() > width) {\n                        angle = -90;\n                        break;\n                    }\n                    angle = -45;\n                }\n            }\n\n            if (angle) {\n                for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                    labels[idx$1].options.rotation = angle;\n                    labels[idx$1].reflow(new Box());\n                }\n                return true;\n            }\n        }\n    };\n\n    Axis.prototype.arrangeTitle = function arrangeTitle () {\n        var ref = this;\n        var options = ref.options;\n        var title = ref.title;\n        var mirror = options.labels.mirror;\n        var vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    };\n\n    Axis.prototype.arrangeNotes = function arrangeNotes () {\n        var this$1 = this;\n\n        for (var idx = 0; idx < this.notes.length; idx++) {\n            var item = this$1.notes[idx];\n            var value = item.options.value;\n            var slot = (void 0);\n\n            if (defined(value)) {\n                if (this$1.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this$1.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this$1.lineBox());\n        }\n    };\n\n    Axis.prototype.noteSlot = function noteSlot (value) {\n        return this.getSlot(value);\n    };\n\n    Axis.prototype.alignTo = function alignTo (secondAxis) {\n        var lineBox = secondAxis.lineBox();\n        var vertical = this.options.vertical;\n        var pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    };\n\n    Axis.prototype.axisLabelText = function axisLabelText (value, dataItem, options) {\n        var tmpl = getTemplate(options);\n        var text = value;\n\n        if (tmpl) {\n            text = tmpl({ value: value, dataItem: dataItem, format: options.format, culture: options.culture });\n        } else if (options.format) {\n            text = this.chartService.format.localeAuto(options.format, [ value ], options.culture);\n        }\n\n        return text;\n    };\n\n    Axis.prototype.slot = function slot (from , to, limit) {\n        var slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    };\n\n    Axis.prototype.contentBox = function contentBox () {\n        var box = this.box.clone();\n        var labels = this.labels;\n        if (labels.length) {\n            var axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                var offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                var lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    };\n\n    Axis.prototype.maxLabelOffset = function maxLabelOffset () {\n        var this$1 = this;\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var tickPositions = this.getLabelsTickPositions();\n        var offsetField = vertical ? Y : X;\n        var labels = this.labels;\n        var startPosition = reverse ? 1 : 0;\n        var endPosition = reverse ? 0 : 1;\n        var maxStartOffset = 0;\n        var maxEndOffset = 0;\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var startTick = (void 0), endTick = (void 0);\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    };\n\n    Axis.prototype.limitRange = function limitRange (from, to, min, max, offset) {\n        var options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        var rangeSize = to - from;\n        var minValue = from;\n        var maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    };\n\n    Axis.prototype.valueRange = function valueRange () {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    };\n\n    Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks () {\n        return !this.options.justified;\n    };\n\n    //add legacy fields to the options that are no longer generated by default\n    Axis.prototype.prepareUserOptions = function prepareUserOptions () {\n    };\n\n    return Axis;\n}(ChartElement));\n\nsetDefaultOptions(Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\nexport default Axis;\n"]},"metadata":{},"sourceType":"module"}