{"ast":null,"code":"import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nvar Ring = function (Class) {\n  function Ring(center, innerRadius, radius, startAngle, angle) {\n    Class.call(this);\n    this.center = center;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.startAngle = startAngle;\n    this.angle = angle;\n  }\n\n  if (Class) Ring.__proto__ = Class;\n  Ring.prototype = Object.create(Class && Class.prototype);\n  Ring.prototype.constructor = Ring;\n\n  Ring.prototype.clone = function clone() {\n    return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n  };\n\n  Ring.prototype.middle = function middle() {\n    return this.startAngle + this.angle / 2;\n  };\n\n  Ring.prototype.setRadius = function setRadius(newRadius, innerRadius) {\n    if (innerRadius) {\n      this.innerRadius = newRadius;\n    } else {\n      this.radius = newRadius;\n    }\n\n    return this;\n  }; // TODO: Remove and replace with Point.onCircle\n\n\n  Ring.prototype.point = function point(angle, innerRadius) {\n    var radianAngle = rad(angle);\n    var ax = Math.cos(radianAngle);\n    var ay = Math.sin(radianAngle);\n    var radius = innerRadius ? this.innerRadius : this.radius;\n    var x = round(this.center.x - ax * radius, COORD_PRECISION);\n    var y = round(this.center.y - ay * radius, COORD_PRECISION);\n    return new Point(x, y);\n  };\n\n  Ring.prototype.adjacentBox = function adjacentBox(distance, width, height) {\n    var sector = this.clone().expand(distance);\n    var midAndle = sector.middle();\n    var midPoint = sector.point(midAndle);\n    var hw = width / 2;\n    var hh = height / 2;\n    var sa = Math.sin(rad(midAndle));\n    var ca = Math.cos(rad(midAndle));\n    var x = midPoint.x - hw;\n    var y = midPoint.y - hh;\n\n    if (Math.abs(sa) < 0.9) {\n      x += hw * -ca / Math.abs(ca);\n    }\n\n    if (Math.abs(ca) < 0.9) {\n      y += hh * -sa / Math.abs(sa);\n    }\n\n    return new Box(x, y, x + width, y + height);\n  };\n\n  Ring.prototype.containsPoint = function containsPoint(p) {\n    var center = this.center;\n    var innerRadius = this.innerRadius;\n    var radius = this.radius;\n    var startAngle = this.startAngle;\n    var endAngle = this.startAngle + this.angle;\n    var dx = p.x - center.x;\n    var dy = p.y - center.y;\n    var vector = new Point(dx, dy);\n    var startPoint = this.point(startAngle);\n    var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n    var endPoint = this.point(endAngle);\n    var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n    var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n  };\n\n  Ring.prototype.getBBox = function getBBox() {\n    var this$1 = this;\n    var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n    var startAngle = round(this.startAngle % 360);\n    var endAngle = round((startAngle + this.angle) % 360);\n    var innerRadius = this.innerRadius;\n    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n    var startAngleIndex = allAngles.indexOf(startAngle);\n    var endAngleIndex = allAngles.indexOf(endAngle);\n    var angles;\n\n    if (startAngle === endAngle) {\n      angles = allAngles;\n    } else {\n      if (startAngleIndex < endAngleIndex) {\n        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n      } else {\n        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n      }\n    }\n\n    for (var i = 0; i < angles.length; i++) {\n      var point = this$1.point(angles[i]);\n      box.wrapPoint(point);\n      box.wrapPoint(point, innerRadius);\n    }\n\n    if (!innerRadius) {\n      box.wrapPoint(this.center);\n    }\n\n    return box;\n  };\n\n  Ring.prototype.expand = function expand(value) {\n    this.radius += value;\n    return this;\n  };\n\n  return Ring;\n}(Class);\n\nfunction numericComparer(a, b) {\n  return a - b;\n}\n\nexport default Ring;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/core/ring.js"],"names":["Box","Point","COORD_PRECISION","MAX_VALUE","MIN_VALUE","Class","clockwise","rad","round","Ring","center","innerRadius","radius","startAngle","angle","call","__proto__","prototype","Object","create","constructor","clone","middle","setRadius","newRadius","point","radianAngle","ax","Math","cos","ay","sin","x","y","adjacentBox","distance","width","height","sector","expand","midAndle","midPoint","hw","hh","sa","ca","abs","containsPoint","p","endAngle","dx","dy","vector","startPoint","startVector","endPoint","endVector","dist","equals","getBBox","this$1","box","allAngles","sort","numericComparer","startAngleIndex","indexOf","endAngleIndex","angles","slice","concat","length","i","wrapPoint","value","a","b"],"mappings":"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","sourcesContent":["import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nvar Ring = (function (Class) {\n    function Ring(center, innerRadius, radius, startAngle, angle) {\n        Class.call(this);\n\n        this.center = center;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.angle = angle;\n    }\n\n    if ( Class ) Ring.__proto__ = Class;\n    Ring.prototype = Object.create( Class && Class.prototype );\n    Ring.prototype.constructor = Ring;\n\n    Ring.prototype.clone = function clone () {\n        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n    };\n\n    Ring.prototype.middle = function middle () {\n        return this.startAngle + this.angle / 2;\n    };\n\n    Ring.prototype.setRadius = function setRadius (newRadius, innerRadius) {\n        if (innerRadius) {\n            this.innerRadius = newRadius;\n        } else {\n            this.radius = newRadius;\n        }\n\n        return this;\n    };\n\n    // TODO: Remove and replace with Point.onCircle\n    Ring.prototype.point = function point (angle, innerRadius) {\n        var radianAngle = rad(angle);\n        var ax = Math.cos(radianAngle);\n        var ay = Math.sin(radianAngle);\n        var radius = innerRadius ? this.innerRadius : this.radius;\n        var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n        var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n        return new Point(x, y);\n    };\n\n    Ring.prototype.adjacentBox = function adjacentBox (distance, width, height) {\n        var sector = this.clone().expand(distance);\n        var midAndle = sector.middle();\n        var midPoint = sector.point(midAndle);\n        var hw = width / 2;\n        var hh = height / 2;\n        var sa = Math.sin(rad(midAndle));\n        var ca = Math.cos(rad(midAndle));\n        var x = midPoint.x - hw;\n        var y = midPoint.y - hh;\n\n        if (Math.abs(sa) < 0.9) {\n            x += hw * -ca / Math.abs(ca);\n        }\n\n        if (Math.abs(ca) < 0.9) {\n            y += hh * -sa / Math.abs(sa);\n        }\n\n        return new Box(x, y, x + width, y + height);\n    };\n\n    Ring.prototype.containsPoint = function containsPoint (p) {\n        var center = this.center;\n        var innerRadius = this.innerRadius;\n        var radius = this.radius;\n        var startAngle = this.startAngle;\n        var endAngle = this.startAngle + this.angle;\n        var dx = p.x - center.x;\n        var dy = p.y - center.y;\n        var vector = new Point(dx, dy);\n        var startPoint = this.point(startAngle);\n        var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n        var endPoint = this.point(endAngle);\n        var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n        var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n               !clockwise(endVector, vector) &&\n               dist >= innerRadius * innerRadius && dist <= radius * radius;\n    };\n\n    Ring.prototype.getBBox = function getBBox () {\n        var this$1 = this;\n\n        var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n        var startAngle = round(this.startAngle % 360);\n        var endAngle = round((startAngle + this.angle) % 360);\n        var innerRadius = this.innerRadius;\n        var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n        var startAngleIndex = allAngles.indexOf(startAngle);\n        var endAngleIndex = allAngles.indexOf(endAngle);\n        var angles;\n\n        if (startAngle === endAngle) {\n            angles = allAngles;\n        } else {\n            if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n            } else {\n                angles = [].concat(\n                    allAngles.slice(0, endAngleIndex + 1),\n                    allAngles.slice(startAngleIndex, allAngles.length)\n                );\n            }\n        }\n\n        for (var i = 0; i < angles.length; i++) {\n            var point = this$1.point(angles[i]);\n            box.wrapPoint(point);\n            box.wrapPoint(point, innerRadius);\n        }\n\n        if (!innerRadius) {\n            box.wrapPoint(this.center);\n        }\n\n        return box;\n    };\n\n    Ring.prototype.expand = function expand (value) {\n        this.radius += value;\n        return this;\n    };\n\n    return Ring;\n}(Class));\n\nfunction numericComparer(a, b) {\n    return a - b;\n}\n\nexport default Ring;"]},"metadata":{},"sourceType":"module"}