{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport LineSegment from '../line-chart/line-segment';\nimport { append, deepExtend, isFunction, last } from '../../common';\n\nvar AreaSegment = function (LineSegment) {\n  function AreaSegment(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n    LineSegment.call(this, linePoints, currentSeries, seriesIx);\n    this.prevSegment = prevSegment;\n    this.stackPoints = stackPoints;\n  }\n\n  if (LineSegment) AreaSegment.__proto__ = LineSegment;\n  AreaSegment.prototype = Object.create(LineSegment && LineSegment.prototype);\n  AreaSegment.prototype.constructor = AreaSegment;\n\n  AreaSegment.prototype.createVisual = function createVisual() {\n    var series = this.series;\n    var defaults = series._defaults;\n    var lineOptions = series.line || {};\n    var color = series.color;\n\n    if (isFunction(color) && defaults) {\n      color = defaults.color;\n    }\n\n    this.visual = new draw.Group({\n      zIndex: series.zIndex\n    });\n    this.createFill({\n      fill: {\n        color: color,\n        opacity: series.opacity\n      },\n      stroke: null\n    });\n\n    if (lineOptions.width > 0 && lineOptions.visible !== false) {\n      this.createStroke({\n        stroke: deepExtend({\n          color: color,\n          opacity: series.opacity,\n          lineCap: \"butt\"\n        }, lineOptions)\n      });\n    }\n  };\n\n  AreaSegment.prototype.strokeSegments = function strokeSegments() {\n    var segments = this._strokeSegments;\n\n    if (!segments) {\n      segments = this._strokeSegments = this.createStrokeSegments();\n    }\n\n    return segments;\n  };\n\n  AreaSegment.prototype.createStrokeSegments = function createStrokeSegments() {\n    return this.segmentsFromPoints(this.points());\n  };\n\n  AreaSegment.prototype.stackSegments = function stackSegments() {\n    if (this.prevSegment) {\n      return this.prevSegment.createStackSegments(this.stackPoints);\n    }\n\n    return this.createStackSegments(this.stackPoints);\n  };\n\n  AreaSegment.prototype.createStackSegments = function createStackSegments(stackPoints) {\n    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n  };\n\n  AreaSegment.prototype.segmentsFromPoints = function segmentsFromPoints(points) {\n    return points.map(function (point) {\n      return new geom.Segment(point);\n    });\n  };\n\n  AreaSegment.prototype.createStroke = function createStroke(style) {\n    var stroke = new draw.Path(style);\n    stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n    this.visual.append(stroke);\n  };\n\n  AreaSegment.prototype.hasStackSegment = function hasStackSegment() {\n    return this.prevSegment || this.stackPoints && this.stackPoints.length;\n  };\n\n  AreaSegment.prototype.createFill = function createFill(style) {\n    var strokeSegments = this.strokeSegments();\n    var fillSegments = strokeSegments.slice(0);\n    var hasStackSegments = this.hasStackSegment();\n\n    if (hasStackSegments) {\n      var stackSegments = this.stackSegments();\n      append(fillSegments, stackSegments);\n    }\n\n    var fill = new draw.Path(style);\n    fill.segments.push.apply(fill.segments, fillSegments);\n\n    if (!hasStackSegments && strokeSegments.length > 1) {\n      this.fillToAxes(fill);\n    }\n\n    this.visual.append(fill);\n  };\n\n  AreaSegment.prototype.fillToAxes = function fillToAxes(fillPath) {\n    var chart = this.parent;\n    var invertAxes = chart.options.invertAxes;\n    var valueAxis = chart.seriesValueAxis(this.series);\n    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n    var segments = this.strokeSegments();\n    var firstPoint = segments[0].anchor();\n    var lastPoint = last(segments).anchor();\n    var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n    if (invertAxes) {\n      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);\n    } else {\n      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);\n    }\n  };\n\n  return AreaSegment;\n}(LineSegment);\n\nexport default AreaSegment;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js"],"names":["drawing","draw","geometry","geom","LineSegment","append","deepExtend","isFunction","last","AreaSegment","linePoints","currentSeries","seriesIx","prevSegment","stackPoints","call","__proto__","prototype","Object","create","constructor","createVisual","series","defaults","_defaults","lineOptions","line","color","visual","Group","zIndex","createFill","fill","opacity","stroke","width","visible","createStroke","lineCap","strokeSegments","segments","_strokeSegments","createStrokeSegments","segmentsFromPoints","points","stackSegments","createStackSegments","toGeometryPoints","reverse","map","point","Segment","style","Path","push","apply","hasStackSegment","length","fillSegments","slice","hasStackSegments","fillToAxes","fillPath","chart","parent","invertAxes","options","valueAxis","seriesValueAxis","crossingValue","categoryAxisCrossingValue","endSlot","getSlot","firstPoint","anchor","lastPoint","end","x1","y1","lineTo","y","x"],"mappings":"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","sourcesContent":["import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport LineSegment from '../line-chart/line-segment';\n\nimport { append, deepExtend, isFunction, last } from '../../common';\n\nvar AreaSegment = (function (LineSegment) {\n    function AreaSegment(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n        LineSegment.call(this, linePoints, currentSeries, seriesIx);\n\n        this.prevSegment = prevSegment;\n        this.stackPoints = stackPoints;\n    }\n\n    if ( LineSegment ) AreaSegment.__proto__ = LineSegment;\n    AreaSegment.prototype = Object.create( LineSegment && LineSegment.prototype );\n    AreaSegment.prototype.constructor = AreaSegment;\n\n    AreaSegment.prototype.createVisual = function createVisual () {\n        var series = this.series;\n        var defaults = series._defaults;\n        var lineOptions = series.line || {};\n        var color = series.color;\n\n        if (isFunction(color) && defaults) {\n            color = defaults.color;\n        }\n\n        this.visual = new draw.Group({\n            zIndex: series.zIndex\n        });\n\n        this.createFill({\n            fill: {\n                color: color,\n                opacity: series.opacity\n            },\n            stroke: null\n        });\n\n        if (lineOptions.width > 0 && lineOptions.visible !== false) {\n            this.createStroke({\n                stroke: deepExtend({\n                    color: color,\n                    opacity: series.opacity,\n                    lineCap: \"butt\"\n                }, lineOptions)\n            });\n        }\n    };\n\n    AreaSegment.prototype.strokeSegments = function strokeSegments () {\n        var segments = this._strokeSegments;\n\n        if (!segments) {\n            segments = this._strokeSegments = this.createStrokeSegments();\n        }\n\n        return segments;\n    };\n\n    AreaSegment.prototype.createStrokeSegments = function createStrokeSegments () {\n        return this.segmentsFromPoints(this.points());\n    };\n\n    AreaSegment.prototype.stackSegments = function stackSegments () {\n        if (this.prevSegment) {\n            return this.prevSegment.createStackSegments(this.stackPoints);\n        }\n\n        return this.createStackSegments(this.stackPoints);\n    };\n\n    AreaSegment.prototype.createStackSegments = function createStackSegments (stackPoints) {\n        return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n    };\n\n    AreaSegment.prototype.segmentsFromPoints = function segmentsFromPoints (points) {\n        return points.map(function (point) { return new geom.Segment(point); });\n    };\n\n    AreaSegment.prototype.createStroke = function createStroke (style) {\n        var stroke = new draw.Path(style);\n        stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n\n        this.visual.append(stroke);\n    };\n\n    AreaSegment.prototype.hasStackSegment = function hasStackSegment () {\n        return this.prevSegment || (this.stackPoints && this.stackPoints.length);\n    };\n\n    AreaSegment.prototype.createFill = function createFill (style) {\n        var strokeSegments = this.strokeSegments();\n        var fillSegments = strokeSegments.slice(0);\n        var hasStackSegments = this.hasStackSegment();\n\n        if (hasStackSegments) {\n            var stackSegments = this.stackSegments();\n\n            append(fillSegments, stackSegments);\n        }\n\n        var fill = new draw.Path(style);\n        fill.segments.push.apply(fill.segments, fillSegments);\n\n        if (!hasStackSegments && strokeSegments.length > 1) {\n            this.fillToAxes(fill);\n        }\n\n        this.visual.append(fill);\n    };\n\n    AreaSegment.prototype.fillToAxes = function fillToAxes (fillPath) {\n        var chart = this.parent;\n        var invertAxes = chart.options.invertAxes;\n        var valueAxis = chart.seriesValueAxis(this.series);\n        var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n        var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n        var segments = this.strokeSegments();\n        var firstPoint = segments[0].anchor();\n        var lastPoint = last(segments).anchor();\n        var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n        if (invertAxes) {\n            fillPath.lineTo(end, lastPoint.y)\n                    .lineTo(end, firstPoint.y);\n        } else {\n            fillPath.lineTo(lastPoint.x, end)\n                    .lineTo(firstPoint.x, end);\n        }\n    };\n\n    return AreaSegment;\n}(LineSegment));\n\nexport default AreaSegment;"]},"metadata":{},"sourceType":"module"}