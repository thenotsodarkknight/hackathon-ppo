{"ast":null,"code":"import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\nimport { STEP, SMOOTH, ZERO } from '../constants';\n\nvar AreaChart = function (LineChart) {\n  function AreaChart() {\n    LineChart.apply(this, arguments);\n  }\n\n  if (LineChart) AreaChart.__proto__ = LineChart;\n  AreaChart.prototype = Object.create(LineChart && LineChart.prototype);\n  AreaChart.prototype.constructor = AreaChart;\n\n  AreaChart.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n    var isStacked = this.options.isStacked;\n    var style = (currentSeries.line || {}).style;\n    var previousSegment;\n    var stackPoints;\n\n    if (isStacked && seriesIx > 0 && prevSegment) {\n      var missingValues = this.seriesMissingValues(currentSeries);\n\n      if (missingValues !== \"gap\") {\n        stackPoints = prevSegment.linePoints;\n        previousSegment = prevSegment;\n      } else {\n        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n      }\n    }\n\n    var pointType;\n\n    if (style === STEP) {\n      pointType = StepAreaSegment;\n    } else if (style === SMOOTH) {\n      pointType = SplineAreaSegment;\n    } else {\n      pointType = AreaSegment;\n    }\n\n    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n  };\n\n  AreaChart.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    LineChart.prototype.reflow.call(this, targetBox);\n    var stackPoints = this._stackPoints;\n\n    if (stackPoints) {\n      for (var idx = 0; idx < stackPoints.length; idx++) {\n        var stackPoint = stackPoints[idx];\n        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n        stackPoint.reflow(pointSlot);\n      }\n    }\n  };\n\n  AreaChart.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {\n    var this$1 = this;\n    var seriesPoints = this.seriesPoints;\n    var startIdx = linePoints[0].categoryIx;\n    var length = linePoints.length;\n\n    if (startIdx < 0) {\n      startIdx = 0;\n      length--;\n    }\n\n    var endIdx = startIdx + length;\n    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n    var stackPoints = [];\n    this._stackPoints = this._stackPoints || [];\n\n    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n      var pointIx = categoryIx + pointOffset;\n      var currentSeriesIx = seriesIx;\n      var point = void 0;\n\n      do {\n        currentSeriesIx--;\n        point = seriesPoints[currentSeriesIx][pointIx];\n      } while (currentSeriesIx > 0 && !point);\n\n      if (point) {\n        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n        }\n\n        stackPoints.push(point);\n\n        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n        }\n      } else {\n        var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n\n        this$1._stackPoints.push(gapStackPoint);\n\n        stackPoints.push(gapStackPoint);\n      }\n    }\n\n    return stackPoints;\n  };\n\n  AreaChart.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n    var seriesPoints = this.seriesPoints;\n    var index = seriesIdx;\n    var point;\n\n    while (index > 0 && !point) {\n      index--;\n      point = seriesPoints[index][segmentIx];\n    }\n\n    if (!point) {\n      point = this._createGapStackPoint(categoryIx);\n\n      this._stackPoints.push(point);\n    } else {\n      point = seriesPoints[index][pointIx];\n    }\n\n    return point;\n  };\n\n  AreaChart.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {\n    var options = this.pointOptions({}, 0);\n    var point = new LinePoint(0, options);\n    point.categoryIx = categoryIx;\n    point.series = {};\n    return point;\n  };\n\n  AreaChart.prototype.seriesMissingValues = function seriesMissingValues(series) {\n    return series.missingValues || ZERO;\n  };\n\n  return AreaChart;\n}(LineChart);\n\nexport default AreaChart;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js"],"names":["LineChart","LinePoint","AreaSegment","StepAreaSegment","SplineAreaSegment","STEP","SMOOTH","ZERO","AreaChart","apply","arguments","__proto__","prototype","Object","create","constructor","createSegment","linePoints","currentSeries","seriesIx","prevSegment","isStacked","options","style","line","previousSegment","stackPoints","missingValues","seriesMissingValues","_gapStackPoints","pointType","reflow","targetBox","this$1","call","_stackPoints","idx","length","stackPoint","pointSlot","categoryAxis","getSlot","categoryIx","seriesPoints","startIdx","endIdx","pointOffset","seriesOptions","_outOfRangeMinPoint","pointIx","currentSeriesIx","point","push","_previousSegmentPoint","gapStackPoint","_createGapStackPoint","segmentIx","seriesIdx","index","pointOptions","series"],"mappings":"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","sourcesContent":["import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\n\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\n\nimport { STEP, SMOOTH, ZERO } from '../constants';\n\nvar AreaChart = (function (LineChart) {\n    function AreaChart () {\n        LineChart.apply(this, arguments);\n    }\n\n    if ( LineChart ) AreaChart.__proto__ = LineChart;\n    AreaChart.prototype = Object.create( LineChart && LineChart.prototype );\n    AreaChart.prototype.constructor = AreaChart;\n\n    AreaChart.prototype.createSegment = function createSegment (linePoints, currentSeries, seriesIx, prevSegment) {\n        var isStacked = this.options.isStacked;\n        var style = (currentSeries.line || {}).style;\n        var previousSegment;\n\n        var stackPoints;\n        if (isStacked && seriesIx > 0 && prevSegment) {\n            var missingValues = this.seriesMissingValues(currentSeries);\n            if (missingValues !== \"gap\") {\n                stackPoints = prevSegment.linePoints;\n                previousSegment = prevSegment;\n            } else {\n                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n            }\n        }\n\n        var pointType;\n        if (style === STEP) {\n            pointType = StepAreaSegment;\n        } else if (style === SMOOTH) {\n            pointType = SplineAreaSegment;\n        } else {\n            pointType = AreaSegment;\n        }\n\n        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n    };\n\n    AreaChart.prototype.reflow = function reflow (targetBox) {\n        var this$1 = this;\n\n        LineChart.prototype.reflow.call(this, targetBox);\n\n        var stackPoints = this._stackPoints;\n        if (stackPoints) {\n            for (var idx = 0; idx < stackPoints.length; idx++) {\n                var stackPoint = stackPoints[idx];\n                var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\n                stackPoint.reflow(pointSlot);\n            }\n        }\n    };\n\n    AreaChart.prototype._gapStackPoints = function _gapStackPoints (linePoints, seriesIx, style) {\n        var this$1 = this;\n\n        var seriesPoints = this.seriesPoints;\n        var startIdx = linePoints[0].categoryIx;\n        var length = linePoints.length;\n        if (startIdx < 0) {\n            startIdx = 0;\n            length--;\n        }\n\n        var endIdx = startIdx + length;\n        var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n        var stackPoints = [];\n\n        this._stackPoints = this._stackPoints || [];\n        for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n            var pointIx = categoryIx + pointOffset;\n            var currentSeriesIx = seriesIx;\n            var point = (void 0);\n\n            do {\n                currentSeriesIx--;\n                point = seriesPoints[currentSeriesIx][pointIx];\n            } while (currentSeriesIx > 0 && !point);\n\n            if (point) {\n                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                }\n\n                stackPoints.push(point);\n\n                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                }\n            } else {\n                var gapStackPoint = this$1._createGapStackPoint(categoryIx);\n                this$1._stackPoints.push(gapStackPoint);\n                stackPoints.push(gapStackPoint);\n            }\n        }\n\n        return stackPoints;\n    };\n\n    AreaChart.prototype._previousSegmentPoint = function _previousSegmentPoint (categoryIx, pointIx, segmentIx, seriesIdx) {\n        var seriesPoints = this.seriesPoints;\n        var index = seriesIdx;\n        var point;\n\n        while (index > 0 && !point) {\n            index--;\n            point = seriesPoints[index][segmentIx];\n        }\n\n        if (!point) {\n            point = this._createGapStackPoint(categoryIx);\n            this._stackPoints.push(point);\n        } else {\n            point = seriesPoints[index][pointIx];\n        }\n\n        return point;\n    };\n\n    AreaChart.prototype._createGapStackPoint = function _createGapStackPoint (categoryIx) {\n        var options = this.pointOptions({}, 0);\n        var point = new LinePoint(0, options);\n        point.categoryIx = categoryIx;\n        point.series = {};\n\n        return point;\n    };\n\n    AreaChart.prototype.seriesMissingValues = function seriesMissingValues (series) {\n        return series.missingValues || ZERO;\n    };\n\n    return AreaChart;\n}(LineChart));\n\nexport default AreaChart;"]},"metadata":{},"sourceType":"module"}