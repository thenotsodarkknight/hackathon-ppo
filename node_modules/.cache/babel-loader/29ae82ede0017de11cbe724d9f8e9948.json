{"ast":null,"code":"import { geometry as geom, Color } from '@progress/kendo-drawing';\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\nimport { bindSegments, evalOptions } from '../utils';\nimport { BLACK, WHITE, CENTER, LEFT } from '../../common/constants';\nimport { deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\n\nvar FunnelChart = function (ChartElement) {\n  function FunnelChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.points = [];\n    this.labels = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  if (ChartElement) FunnelChart.__proto__ = ChartElement;\n  FunnelChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  FunnelChart.prototype.constructor = FunnelChart;\n\n  FunnelChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  FunnelChart.prototype.render = function render() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var seriesColors = ref.plotArea.options.seriesColors;\n    if (seriesColors === void 0) seriesColors = [];\n    var series = options.series[0];\n    var data = series.data;\n\n    if (!data) {\n      return;\n    }\n\n    var ref$1 = bindSegments(series);\n    var total = ref$1.total;\n    var points = ref$1.points;\n\n    for (var i = 0; i < points.length; i++) {\n      var pointData = points[i];\n\n      if (!pointData) {\n        continue;\n      }\n\n      var fields = pointData.fields;\n\n      if (!isFunction(series.color)) {\n        series.color = fields.color || seriesColors[i % seriesColors.length];\n      }\n\n      fields = deepExtend({\n        index: i,\n        owner: this$1,\n        series: series,\n        dataItem: data[i],\n        percentage: pointData.value / total\n      }, fields, {\n        visible: pointData.visible\n      });\n      var value = pointData.valueFields.value;\n      var segment = this$1.createSegment(value, fields);\n      var label = this$1.createLabel(value, fields);\n\n      if (segment && label) {\n        segment.append(label);\n      }\n    }\n  };\n\n  FunnelChart.prototype.evalSegmentOptions = function evalSegmentOptions(options, value, fields) {\n    var series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      index: fields.index\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"toggle\", \"visual\"]\n    });\n  };\n\n  FunnelChart.prototype.createSegment = function createSegment(value, fields) {\n    var seriesOptions = deepExtend({}, fields.series);\n    this.evalSegmentOptions(seriesOptions, value, fields);\n    this.createLegendItem(value, seriesOptions, fields);\n\n    if (fields.visible !== false) {\n      var segment = new FunnelSegment(value, seriesOptions, fields);\n      Object.assign(segment, fields);\n      this.append(segment);\n      this.points.push(segment);\n      return segment;\n    }\n  };\n\n  FunnelChart.prototype.createLabel = function createLabel(value, fields) {\n    var series = fields.series;\n    var dataItem = fields.dataItem;\n    var labels = deepExtend({}, this.options.labels, series.labels);\n    var text = value;\n\n    if (labels.visible) {\n      var labelTemplate = getTemplate(labels);\n      var data = {\n        dataItem: dataItem,\n        value: value,\n        percentage: fields.percentage,\n        category: fields.category,\n        series: series\n      };\n\n      if (labelTemplate) {\n        text = labelTemplate(data);\n      } else if (labels.format) {\n        text = this.plotArea.chartService.format.auto(labels.format, text);\n      }\n\n      if (!labels.color) {\n        var brightnessValue = new Color(series.color).percBrightness();\n\n        if (brightnessValue > 180) {\n          labels.color = BLACK;\n        } else {\n          labels.color = WHITE;\n        }\n\n        if (!labels.background) {\n          labels.background = series.color;\n        }\n      }\n\n      this.evalSegmentOptions(labels, value, fields);\n      var textBox = new TextBox(text, deepExtend({\n        vAlign: labels.position\n      }, labels), data);\n      this.labels.push(textBox);\n      return textBox;\n    }\n  };\n\n  FunnelChart.prototype.labelPadding = function labelPadding() {\n    var labels = this.labels;\n    var padding = {\n      left: 0,\n      right: 0\n    };\n\n    for (var i = 0; i < labels.length; i++) {\n      var label = labels[i];\n      var align = label.options.align;\n\n      if (align !== CENTER) {\n        var width = labels[i].box.width();\n\n        if (align === LEFT) {\n          padding.left = Math.max(padding.left, width);\n        } else {\n          padding.right = Math.max(padding.right, width);\n        }\n      }\n    }\n\n    return padding;\n  };\n\n  FunnelChart.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {\n    var ref = this;\n    var options = ref.options;\n    var segments = ref.points;\n    var count = segments.length;\n    var firstSegment = segments[0];\n    var maxSegment = firstSegment;\n\n    for (var idx = 0; idx < segments.length; idx++) {\n      if (segments[idx].percentage > maxSegment.percentage) {\n        maxSegment = segments[idx];\n      }\n    }\n\n    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;\n    var previousOffset = (width - lastUpperSide) / 2;\n    var previousHeight = 0;\n\n    for (var idx$1 = 0; idx$1 < count; idx$1++) {\n      var percentage = segments[idx$1].percentage;\n      var nextSegment = segments[idx$1 + 1];\n      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;\n      var points = segments[idx$1].points = [];\n      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      var offset = void 0;\n\n      if (!percentage) {\n        offset = nextPercentage ? 0 : width / 2;\n      } else {\n        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n      }\n\n      offset = limitValue(offset, 0, width);\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n      previousOffset = offset;\n      previousHeight += height + options.segmentSpacing;\n      lastUpperSide = limitValue(width - 2 * offset, 0, width);\n    }\n  };\n\n  FunnelChart.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {\n    var ref = this;\n    var options = ref.options;\n    var segments = ref.points;\n    var count = segments.length;\n    var decreasingWidth = options.neckRatio <= 1;\n    var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n    var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n    var finalNarrow = (topMostWidth - neckRatio) / 2;\n    var previousHeight = 0;\n\n    for (var idx = 0; idx < count; idx++) {\n      var points = segments[idx].points = [];\n      var percentage = segments[idx].percentage;\n      var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;\n      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));\n      previousOffset += offset;\n      previousHeight += height + options.segmentSpacing;\n    }\n  };\n\n  FunnelChart.prototype.reflow = function reflow(chartBox) {\n    var points = this.points;\n    var count = points.length;\n\n    if (!count) {\n      return;\n    }\n\n    var options = this.options;\n    var box = chartBox.clone().unpad(this.labelPadding());\n    var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n    var width = box.width();\n\n    if (options.dynamicSlope) {\n      this.dynamicSlopeReflow(box, width, totalHeight);\n    } else {\n      this.constantSlopeReflow(box, width, totalHeight);\n    }\n\n    for (var idx = 0; idx < count; idx++) {\n      points[idx].reflow(chartBox);\n    }\n  };\n\n  return FunnelChart;\n}(ChartElement);\n\nsetDefaultOptions(FunnelChart, {\n  neckRatio: 0.3,\n  width: 300,\n  dynamicSlope: false,\n  dynamicHeight: true,\n  segmentSpacing: 0,\n  labels: {\n    visible: false,\n    align: CENTER,\n    position: CENTER,\n    zIndex: 1\n  }\n});\ndeepExtend(FunnelChart.prototype, PieChartMixin);\nexport default FunnelChart;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js"],"names":["geometry","geom","Color","ChartElement","TextBox","PieChartMixin","FunnelSegment","bindSegments","evalOptions","BLACK","WHITE","CENTER","LEFT","deepExtend","isFunction","getTemplate","limitValue","setDefaultOptions","FunnelChart","plotArea","options","call","points","labels","legendItems","render","__proto__","prototype","Object","create","constructor","formatPointValue","point","format","chartService","auto","value","this$1","ref","seriesColors","series","data","ref$1","total","i","length","pointData","fields","color","index","owner","dataItem","percentage","visible","valueFields","segment","createSegment","label","createLabel","append","evalSegmentOptions","defaults","_defaults","excluded","seriesOptions","createLegendItem","assign","push","text","labelTemplate","category","brightnessValue","percBrightness","background","textBox","vAlign","position","labelPadding","padding","left","right","align","width","box","Math","max","dynamicSlopeReflow","totalHeight","segments","count","firstSegment","maxSegment","idx","lastUpperSide","previousOffset","previousHeight","idx$1","nextSegment","nextPercentage","height","dynamicHeight","offset","Point","x1","y1","segmentSpacing","constantSlopeReflow","decreasingWidth","neckRatio","topMostWidth","finalNarrow","reflow","chartBox","clone","unpad","dynamicSlope","zIndex"],"mappings":"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","sourcesContent":["import { geometry as geom, Color } from '@progress/kendo-drawing';\n\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\n\nimport { bindSegments, evalOptions } from '../utils';\n\nimport { BLACK, WHITE, CENTER, LEFT } from '../../common/constants';\nimport { deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\n\nvar FunnelChart = (function (ChartElement) {\n    function FunnelChart(plotArea, options) {\n        ChartElement.call(this, options);\n\n        this.plotArea = plotArea;\n        this.points = [];\n        this.labels = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    if ( ChartElement ) FunnelChart.__proto__ = ChartElement;\n    FunnelChart.prototype = Object.create( ChartElement && ChartElement.prototype );\n    FunnelChart.prototype.constructor = FunnelChart;\n\n    FunnelChart.prototype.formatPointValue = function formatPointValue (point, format) {\n        return this.chartService.format.auto(format,point.value);\n    };\n\n    FunnelChart.prototype.render = function render () {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var seriesColors = ref.plotArea.options.seriesColors; if ( seriesColors === void 0 ) seriesColors = [];\n        var series = options.series[0];\n        var data = series.data;\n\n        if (!data) {\n            return;\n        }\n\n        var ref$1 = bindSegments(series);\n        var total = ref$1.total;\n        var points = ref$1.points;\n\n        for (var i = 0; i < points.length; i++) {\n            var pointData = points[i];\n\n            if (!pointData) {\n                continue;\n            }\n\n            var fields = pointData.fields;\n\n            if (!isFunction(series.color)) {\n                series.color = fields.color || seriesColors[i % seriesColors.length];\n            }\n\n            fields = deepExtend({\n                index: i,\n                owner: this$1,\n                series: series,\n                dataItem: data[i],\n                percentage: pointData.value / total\n            }, fields, { visible: pointData.visible });\n\n            var value = pointData.valueFields.value;\n            var segment = this$1.createSegment(value, fields);\n            var label = this$1.createLabel(value, fields);\n\n            if (segment && label) {\n                segment.append(label);\n            }\n        }\n    };\n\n    FunnelChart.prototype.evalSegmentOptions = function evalSegmentOptions (options, value, fields) {\n        var series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            index: fields.index\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"toggle\", \"visual\" ] });\n    };\n\n    FunnelChart.prototype.createSegment = function createSegment (value, fields) {\n        var seriesOptions = deepExtend({}, fields.series);\n        this.evalSegmentOptions(seriesOptions, value, fields);\n\n        this.createLegendItem(value, seriesOptions, fields);\n\n        if (fields.visible !== false) {\n\n            var segment = new FunnelSegment(value, seriesOptions, fields);\n            Object.assign(segment, fields);\n\n            this.append(segment);\n            this.points.push(segment);\n\n            return segment;\n        }\n    };\n\n    FunnelChart.prototype.createLabel = function createLabel (value, fields) {\n        var series = fields.series;\n        var dataItem = fields.dataItem;\n        var labels = deepExtend({}, this.options.labels, series.labels);\n        var text = value;\n\n        if (labels.visible) {\n            var labelTemplate = getTemplate(labels);\n            var data = {\n                dataItem: dataItem,\n                value: value,\n                percentage: fields.percentage,\n                category: fields.category,\n                series: series\n            };\n            if (labelTemplate) {\n                text = labelTemplate(data);\n            } else if (labels.format) {\n                text = this.plotArea.chartService.format.auto(labels.format, text);\n            }\n\n            if (!labels.color) {\n                var brightnessValue = new Color(series.color).percBrightness();\n                if (brightnessValue > 180) {\n                    labels.color = BLACK;\n                } else {\n                    labels.color = WHITE;\n                }\n                if (!labels.background) {\n                    labels.background = series.color;\n                }\n            }\n\n            this.evalSegmentOptions(labels, value, fields);\n            var textBox = new TextBox(text, deepExtend({\n                vAlign: labels.position\n            }, labels), data);\n\n            this.labels.push(textBox);\n\n            return textBox;\n        }\n    };\n\n    FunnelChart.prototype.labelPadding = function labelPadding () {\n        var labels = this.labels;\n        var padding = { left: 0, right: 0 };\n\n        for (var i = 0; i < labels.length; i++) {\n            var label = labels[i];\n            var align = label.options.align;\n            if (align !== CENTER) {\n                var width = labels[i].box.width();\n\n                if (align === LEFT) {\n                    padding.left = Math.max(padding.left, width);\n                } else {\n                    padding.right = Math.max(padding.right, width);\n                }\n            }\n        }\n\n        return padding;\n    };\n\n    FunnelChart.prototype.dynamicSlopeReflow = function dynamicSlopeReflow (box, width, totalHeight) {\n        var ref = this;\n        var options = ref.options;\n        var segments = ref.points;\n        var count = segments.length;\n        var firstSegment = segments[0];\n        var maxSegment = firstSegment;\n\n        for (var idx = 0; idx < segments.length; idx++) {\n            if (segments[idx].percentage > maxSegment.percentage) {\n                maxSegment = segments[idx];\n            }\n        }\n\n        var lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\n        var previousOffset = (width - lastUpperSide) / 2;\n        var previousHeight = 0;\n\n        for (var idx$1 = 0; idx$1 < count; idx$1++) {\n            var percentage = segments[idx$1].percentage;\n            var nextSegment = segments[idx$1 + 1];\n            var nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\n            var points = segments[idx$1].points = [];\n            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n            var offset = (void 0);\n\n            if (!percentage) {\n                offset = nextPercentage ? 0 : width / 2;\n            } else {\n                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n            }\n\n            offset = limitValue(offset, 0, width);\n\n            points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n            points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n\n            previousOffset = offset;\n            previousHeight += height + options.segmentSpacing;\n            lastUpperSide = limitValue(width - 2 * offset, 0, width);\n        }\n    };\n\n    FunnelChart.prototype.constantSlopeReflow = function constantSlopeReflow (box, width, totalHeight) {\n        var ref = this;\n        var options = ref.options;\n        var segments = ref.points;\n        var count = segments.length;\n        var decreasingWidth = options.neckRatio <= 1;\n        var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n        var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n        var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n        var finalNarrow = (topMostWidth - neckRatio) / 2;\n        var previousHeight = 0;\n\n        for (var idx = 0; idx < count; idx++) {\n            var points = segments[idx].points = [];\n            var percentage = segments[idx].percentage;\n            var offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\n            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\n            points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n            points.push(new geom.Point(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\n            previousOffset += offset;\n            previousHeight += height + options.segmentSpacing;\n        }\n    };\n\n    FunnelChart.prototype.reflow = function reflow (chartBox) {\n        var points = this.points;\n        var count = points.length;\n\n        if (!count) {\n            return;\n        }\n\n        var options = this.options;\n        var box = chartBox.clone().unpad(this.labelPadding());\n        var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n        var width = box.width();\n\n        if (options.dynamicSlope) {\n            this.dynamicSlopeReflow(box, width, totalHeight);\n        } else {\n            this.constantSlopeReflow(box, width, totalHeight);\n        }\n\n        for (var idx = 0; idx < count; idx++) {\n            points[idx].reflow(chartBox);\n        }\n    };\n\n    return FunnelChart;\n}(ChartElement));\n\nsetDefaultOptions(FunnelChart, {\n    neckRatio: 0.3,\n    width: 300,\n    dynamicSlope: false,\n    dynamicHeight: true,\n    segmentSpacing: 0,\n    labels: {\n        visible: false,\n        align: CENTER,\n        position: CENTER,\n        zIndex: 1\n    }\n});\n\ndeepExtend(FunnelChart.prototype, PieChartMixin);\n\nexport default FunnelChart;\n"]},"metadata":{},"sourceType":"module"}