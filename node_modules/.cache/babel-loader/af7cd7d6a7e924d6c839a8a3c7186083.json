{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\nvar RadarNumericAxisMixin = {\n  options: {\n    majorGridLines: {\n      visible: true\n    }\n  },\n  createPlotBands: function createPlotBands() {\n    var this$1 = this;\n    var ref = this.options;\n    var type = ref.majorGridLines.type;\n    var plotBands = ref.plotBands;\n    if (plotBands === void 0) plotBands = [];\n    var altAxis = this.plotArea.polarAxis;\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n\n    for (var i = 0; i < plotBands.length; i++) {\n      var band = plotBands[i];\n      var bandStyle = {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      };\n      var slot = this$1.getSlot(band.from, band.to, true);\n      var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n      var shape = void 0;\n\n      if (type === ARC) {\n        shape = ShapeBuilder.current.createRing(ring, bandStyle);\n      } else {\n        shape = draw.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n      }\n\n      group.append(shape);\n    }\n\n    this.appendVisual(group);\n  },\n  plotBandPoints: function plotBandPoints(ring, angles) {\n    var innerPoints = [];\n    var outerPoints = [];\n    var center = [ring.center.x, ring.center.y];\n    var innerCircle = new geom.Circle(center, ring.innerRadius);\n    var outerCircle = new geom.Circle(center, ring.radius);\n\n    for (var i = 0; i < angles.length; i++) {\n      innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n      outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n    }\n\n    innerPoints.reverse();\n    innerPoints.push(innerPoints[0]);\n    outerPoints.push(outerPoints[0]);\n    return outerPoints.concat(innerPoints);\n  },\n  createGridLines: function createGridLines(altAxis) {\n    var options = this.options;\n    var majorTicks = this.radarMajorGridLinePositions();\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var gridLines = [];\n\n    if (options.majorGridLines.visible) {\n      gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);\n    }\n\n    if (options.minorGridLines.visible) {\n      var minorTicks = this.radarMinorGridLinePositions();\n      append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));\n    }\n\n    return gridLines;\n  },\n  renderGridLines: function renderGridLines(center, ticks, angles, options) {\n    var style = {\n      stroke: {\n        width: options.width,\n        color: options.color,\n        dashType: options.dashType\n      }\n    };\n    var skip = options.skip;\n    if (skip === void 0) skip = 0;\n    var step = options.step;\n    if (step === void 0) step = 0;\n    var container = this.gridLinesVisual();\n\n    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n      var tickRadius = center.y - ticks[tickIx];\n\n      if (tickRadius > 0) {\n        var circle = new geom.Circle([center.x, center.y], tickRadius);\n\n        if (options.type === ARC) {\n          container.append(new draw.Circle(circle, style));\n        } else {\n          var line = new draw.Path(style);\n\n          for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n          }\n\n          line.close();\n          container.append(line);\n        }\n      }\n    }\n\n    return container.children;\n  },\n  getValue: function getValue(point) {\n    var lineBox = this.lineBox();\n    var altAxis = this.plotArea.polarAxis;\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var radius = point.distanceTo(center);\n    var distance = radius;\n\n    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n      majorAngles.sort(function (a, b) {\n        return angularDistance(a, theta) - angularDistance(b, theta);\n      }); // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n      // Angles are derived from triangle (center, point, gridline X)\n\n      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n      var alpha = angularDistance(theta, majorAngles[0]);\n      var gamma = 90 - midAngle;\n      var beta = 180 - alpha - gamma;\n      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n    }\n\n    return this.axisType().prototype.getValue.call(this, new Point(lineBox.x1, lineBox.y2 - distance));\n  }\n};\n\nfunction angularDistance(a, b) {\n  return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nexport default RadarNumericAxisMixin;","map":{"version":3,"sources":["/Users/lazybaccha/Documents/Honeywell/SBE/node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js"],"names":["geometry","geom","drawing","draw","ShapeBuilder","Ring","Point","ARC","append","deg","rad","RadarNumericAxisMixin","options","majorGridLines","visible","createPlotBands","this$1","ref","type","plotBands","altAxis","plotArea","polarAxis","majorAngles","center","box","group","_plotbandGroup","Group","zIndex","i","length","band","bandStyle","fill","color","opacity","stroke","slot","getSlot","from","to","ring","y","y2","y1","shape","current","createRing","Path","fromPoints","plotBandPoints","close","appendVisual","angles","innerPoints","outerPoints","x","innerCircle","Circle","innerRadius","outerCircle","radius","push","pointAt","reverse","concat","createGridLines","majorTicks","radarMajorGridLinePositions","gridLines","renderGridLines","minorGridLines","minorTicks","radarMinorGridLinePositions","ticks","style","width","dashType","skip","step","container","gridLinesVisual","tickIx","tickRadius","circle","line","angleIx","lineTo","children","getValue","point","lineBox","distanceTo","distance","dx","dy","theta","Math","atan2","sort","a","b","angularDistance","midAngle","alpha","gamma","beta","sin","axisType","prototype","call","x1","abs"],"mappings":"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","sourcesContent":["import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\n\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\n\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\n\nvar RadarNumericAxisMixin = {\n    options: {\n        majorGridLines: {\n            visible: true\n        }\n    },\n\n    createPlotBands: function() {\n        var this$1 = this;\n\n        var ref = this.options;\n        var type = ref.majorGridLines.type;\n        var plotBands = ref.plotBands; if ( plotBands === void 0 ) plotBands = [];\n        var altAxis = this.plotArea.polarAxis;\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        for (var i = 0; i < plotBands.length; i++) {\n            var band = plotBands[i];\n            var bandStyle = {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            };\n\n            var slot = this$1.getSlot(band.from, band.to, true);\n            var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n            var shape = (void 0);\n            if (type === ARC) {\n                shape = ShapeBuilder.current.createRing(ring, bandStyle);\n            } else {\n                shape = draw.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n            }\n\n            group.append(shape);\n        }\n\n        this.appendVisual(group);\n    },\n\n    plotBandPoints: function(ring, angles) {\n        var innerPoints = [];\n        var outerPoints = [];\n        var center = [ ring.center.x, ring.center.y ];\n        var innerCircle = new geom.Circle(center, ring.innerRadius);\n        var outerCircle = new geom.Circle(center, ring.radius);\n\n        for (var i = 0; i < angles.length; i++) {\n            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n        }\n\n        innerPoints.reverse();\n        innerPoints.push(innerPoints[0]);\n        outerPoints.push(outerPoints[0]);\n\n        return outerPoints.concat(innerPoints);\n    },\n\n    createGridLines: function(altAxis) {\n        var options = this.options;\n        var majorTicks = this.radarMajorGridLinePositions();\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var gridLines = [];\n\n        if (options.majorGridLines.visible) {\n            gridLines = this.renderGridLines(\n                center, majorTicks, majorAngles, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            var minorTicks = this.radarMinorGridLinePositions();\n            append(gridLines, this.renderGridLines(\n                center, minorTicks, majorAngles, options.minorGridLines\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderGridLines: function(center, ticks, angles, options) {\n        var style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n        var skip = options.skip; if ( skip === void 0 ) skip = 0;\n        var step = options.step; if ( step === void 0 ) step = 0;\n        var container = this.gridLinesVisual();\n\n        for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n            var tickRadius = center.y - ticks[tickIx];\n            if (tickRadius > 0) {\n                var circle = new geom.Circle([ center.x, center.y ], tickRadius);\n                if (options.type === ARC) {\n                    container.append(new draw.Circle(circle, style));\n                } else {\n                    var line = new draw.Path(style);\n                    for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                    }\n\n                    line.close();\n                    container.append(line);\n                }\n            }\n        }\n\n        return container.children;\n    },\n\n    getValue: function(point) {\n        var lineBox = this.lineBox();\n        var altAxis = this.plotArea.polarAxis;\n        var majorAngles = altAxis.majorAngles();\n        var center = altAxis.box.center();\n        var radius = point.distanceTo(center);\n        var distance = radius;\n\n        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n            var dx = point.x - center.x;\n            var dy = point.y - center.y;\n            var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n            majorAngles.sort(function(a, b) {\n                return angularDistance(a, theta) - angularDistance(b, theta);\n            });\n\n            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n            // Angles are derived from triangle (center, point, gridline X)\n            var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n            var alpha = angularDistance(theta, majorAngles[0]);\n            var gamma = 90 - midAngle;\n            var beta = 180 - alpha - gamma;\n\n            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n        }\n\n        return this.axisType().prototype.getValue.call(\n            this, new Point(lineBox.x1, lineBox.y2 - distance)\n        );\n    }\n};\n\nfunction angularDistance(a, b) {\n    return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nexport default RadarNumericAxisMixin;"]},"metadata":{},"sourceType":"module"}